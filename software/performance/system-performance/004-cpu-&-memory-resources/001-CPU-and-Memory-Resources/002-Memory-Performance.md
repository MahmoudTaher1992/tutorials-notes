# B. Memory Performance (Chapter 7)

- **Terminology & Concepts**
    - **Virtual Memory**: The illusion of infinite memory
    - **Paging**:
        - **Demand Paging**: Allocating physical RAM only when accessed
        - **Major Faults** (Disk I/O required) vs. **Minor Faults** (Memory re-mapping)
    - **Swapping**: Moving pages to disk (the performance killer)
    - **Overcommit**: Promising more memory than exists
    - **OOM Killer** (Out of Memory): When the kernel kills processes to survive
    - **File System Cache**: Using "Unused" RAM to cache disk I/O
    - **Shared Memory**: IPC efficiency
- **Memory Architecture**
    - **Hardware**:
        - **MMU** (Memory Management Unit) & **TLB** (Translation Lookaside Buffer)
        - **NUMA** (Non-Uniform Memory Access): Local vs. Remote memory costs
    - **Software**:
        - **Allocators**: `malloc`, `free`, `brk`, `mmap`
        - **Page Replacement**: LRU (Least Recently Used) algorithms
- **Analysis Methodology**
    - **USE Method for Memory**: Utilization (Free RAM), Saturation (Scan/Reclaim rate, OOMs), Errors (Failed allocs)
    - **Leak Detection**: Identifying processes with ever-growing RSS
    - **Working Set Size (WSS)**: Determining how much RAM a process *actually* needs actively
- **Memory Observability Tools**
    - **Standard Metrics**: `free`, `vmstat`, `top`, `ps`
    - **Pressure Stall Information**: `PSI` (Quantifying memory contention)
    - **Kernel Slab**: `slabtop` (Kernel memory usage)
    - **Process Details**: `pmap` (Memory map analysis)
    - **Advanced Tracing**:
        - `drsnoop` (Direct Reclaim snoop)
        - `wss` (Working Set Size estimation tools)
        - `pfaults` (Page fault analysis)
- **Memory Tuning**
    - **Page Sizes**: Using **Huge Pages** / Transparent Huge Pages (THP) to reduce TLB misses
    - **Tunable Parameters**: `vm.swappiness`, `overcommit_memory`
    - **NUMA Binding**: `numactl` to keep memory local to the CPU
    - **Memory Shrinking**: Releasing caches manually (dropping caches)
