Based on **Section 76** of the provided study guide, here is a detailed explanation of **UMA (User-Managed Access)**.

---

# 076: UMA (User-Managed Access)

### 1. What is UMA?
UMA (User-Managed Access) is an OAuth-based standard (currently UMA 2.0) that enables **Party-to-Party delegated authorization**.

While standard OAuth 2.0 is designed for a user to grant an application access to their *own* data (e.g., "I grant Google Maps access to my location"), UMA allows a user to grant **someone else** (or an arbitrary party) access to their data, and manage those permissions centrally.

**The Core Philosophy:** It decouples the **Resource Server** (where the data lives) from the **Authorization Server** (where the policy lives).

### 2. The Problem UMA Solves
In standard OAuth, the scope of authorization is usually binary and user-centric:
*   *Standard OAuth:* "Alice lets App X read Alice's Email."

UMA solves scenarios where sharing and dynamic policy enforcement are required:
*   *UMA Scenario:* "Alice wants to let **Bob** read her Email."
*   *UMA Scenario:* "Alice wants to let **anyone over the age of 18** view this specific photo."
*   *UMA Scenario:* "Alice wants to revoke Bobâ€™s access later from a central dashboard, without telling the Email server directly."

### 3. Key Actors in UMA
UMA introduces specific nuances to the standard OAuth roles:

1.  **Resource Owner (RO):** The person who controls the data (Alice).
2.  **Requesting Party (RqP):** The person *requesting* access to the data (Bob).
3.  **Client:** The application Bob is using to try to access Alice's data.
4.  **Resource Server (RS):** The API hosting the data. In UMA, the RS is **smart**; it talks to the Authorization Server directly to register resources.
5.  **Authorization Server (AS):** The central engine where the RO sets policies (e.g., Keycloak, Gluu).

---

### 4. New Artifacts (Tokens & Tickets)

To make this work, UMA introduces three new concepts on top of OAuth:

*   **PAT (Protection API Token):** An access token the **Resource Server** uses to talk to the **Authorization Server**. It allows the API to say, "Hey AS, I have a new file here, please protect it."
*   **Permission Ticket:** A short-lived ticket given by the Resource Server to the Client when access is denied. It represents "The user tried to access Resource X."
*   **RPT (Requesting Party Token):** The final access token (usually a JWT) given to the Client. This is what the Client sends to the API to get data.

---

### 5. The UMA 2.0 Flow (Step-by-Step)

Here is how a typical UMA transaction works. Imagine Alice has a detailed health record (Resource) on a Hospital API (RS), and Bob (Doctor) wants to read it using an iPad App (Client).

**Phase A: Protection (Setup)**
1.  **Resource Registration:** The Hospital API (RS) uses its **PAT** to tell the Auth Server (AS): "I have a resource called `record-123` belonging to Alice."
2.  **Policy Setting:** Alice logs into the AS (her dashboard) and sets a policy: "Doctors can view `record-123`."

**Phase B: Authorization (Runtime)**
1.  **Access Attempt:** Bob's iPad App (Client) requests `GET /api/record-123` at the Hospital API without a token.
2.  **The Stop & Ticket:** The Hospital API sees no token. Instead of just saying 401 Unauthorized, it talks to the AS, obtains a **Permission Ticket**, and returns it to the Client with a 401 response.
    *   *Translation:* "You can't come in yet. Take this ticket to the Auth Server and ask permission."
3.  **Token Request:** Bob's Client sends the **Permission Ticket** to the Authorization Server's token endpoint.
4.  **Claims Gathering (Optional but powerful):** If the AS doesn't know who Bob is, it may respond with "Need Info." Bob's Client might then be redirected to a login screen or asked to provide a verified credential (like a Medical License).
5.  **Evaluation:** The AS checks the ticket against Alice's policy.
    *   *Check:* Is the requester Bob? Yes. Is Bob a doctor? Yes.
6.  **Issuance:** The AS issues an **RPT (Requesting Party Token)** to Bob's Client.
7.  **Final Access:** Bob's Client sends the RPT to the Hospital API.
8.  **Success:** The API validates the RPT (via introspection or JWT signature) and serves the data.

---

### 6. Key Features of UMA

#### A. Centralized Policy Decision Point (PDP)
In normal API development, the API usually contains logic like `if (user.role == 'admin')`. In UMA, the API contains **no logic**. It simply asks the AS: "Is this token valid for this resource?" This allows Alice to change permissions (e.g., revoke Bob's access) without touching the API.

#### B. Asynchronous Consent
Bob can request access to `photo.jpg`. The AS can see that no policy exists to let Bob in. The AS can then **email Alice**: "Bob wants to see photo.jpg. Approve?"
Bob's Request fails for now, but once Alice clicks "Approve," Bob can retry and succeed. This is impossible in standard OAuth.

#### C. Privacy and Relationship
UMA supports privacy by preventing the Relying Party (Bob's app) from knowing strictly *who* the Resource Owner (Alice) is, unless she reveals it. It focuses on the authorization *policy* rather than identity federation.

### 7. Comparison: OAuth 2.0 vs. UMA

| Feature | Standard OAuth 2.0 | UMA 2.0 |
| :--- | :--- | :--- |
| **Primary Use Case** | User grants App access to User's data. | User grants **Party (Person/Org)** access to User's data. |
| **Logic Location** | Authorization logic often hardcoded in the API. | Authorization logic centralized in the Auth Server. |
| **Resource Awareness** | The Auth Server rarely knows about specific object IDs (e.g., file_id). | The Auth Server is explicitly aware of resources (`record-123`). |
| **Flow Trigger** | Client initiates flow with AS. | Client attempts access at RS first, gets redirected to AS (Ticket). |

### 8. When to use UMA?
You should consider UMA if your application requirements include:
1.  **Sharing:** Users need to share data with other users (classic "Share" button functionality functionality).
2.  **Centralized Control:** You have many microservices and want one dashboard where users can view "Who has access to my data across all services?" and revoke it.
3.  **Fine-Grained Access Control:** You need authorization at the specific resource level (File A vs. File B) rather than just API scope level (Read vs. Write).

### 9. Popular Implementations
UMA is complex to implement from scratch. Most developers use Identity Providers that support UMA natively:
*   **Keycloak:** Has very strong UMA 2.0 support (often called Authorization Services).
*   **Gluu Server:** A pioneer in the UMA space.
*   **WSO2 Identity Server.**
*   **ForgeRock.**
