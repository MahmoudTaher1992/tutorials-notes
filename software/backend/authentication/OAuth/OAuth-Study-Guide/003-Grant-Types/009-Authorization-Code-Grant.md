Based on Part 3, Section 9 of your table of contents, here is a detailed explanation of the **Authorization Code Grant**.

---

# 009 - Authorization Code Grant

The **Authorization Code Grant** is often considered the "gold standard" of OAuth 2.0 flows. It is the most common grant type used because it provides the highest level of security for standard web applications.

### 1. The Core Concept (When to Use)
This grant is designed for **Confidential Clients** (server-side web applications) that can securely store a Client Secret.

*   **Scenario:** You are building a web app using Node.js, Java, Python, or .NET.
*   **The Goal:** You want a user to log in via an Authorization Server (like Google or Auth0) so your server can access data on their behalf.
*   **Key Feature:** The Access Token is never exposed to the User's browser (the "Front Channel"). It is exchanged directly between your server and the Authorization Server (the "Back Channel").

---

### 2. High-Level Flow Diagram

The flow involves three parties:
1.  **User (Resource Owner)**: The human click buttons.
2.  **Client (Your Web App)**: The application running on a server.
3.  **Authorization Server (AS)**: The systems issuing the token (e.g., Google).

**The "Dance":**
1.  **Client** redirects the **User** to the **AS**.
2.  **User** logs in and consents to scopes (permissions).
3.  **AS** redirects the **User** back to the **Client** with a temporary **Code**.
4.  **Client** takes that **Code** + its **Client Secret** and sends them to the **AS** (behind the scenes).
5.  **AS** validates the Code and Secret, then returns the **Access Token**.

---

### 3. Step-by-Step Implementation Details

#### Step 1: The Authorization Request
The Client initiates the flow by redirecting the browser to the Authorization Endpoint.

**HTTP GET Request:**
```http
GET /authorize?
  response_type=code
  &client_id=YOUR_APP_ID
  &redirect_uri=https://yourapp.com/callback
  &scope=read_profile
  &state=xyz123random
  &login_hint=user@example.com (optional)
```

**Key Parameters:**
*   **`response_type=code`**: This tells the server, "Don't give me a token yet. Give me a temporary code."
*   **`client_id`**: Identifies your application.
*   **`redirect_uri`**: Where the AS should send the user after login. This *must* match what is registered in the AS settings exactly.
*   **`scope`**: The permissions requested (e.g., `read_profile`).
*   **`state`**: A random string generated by your app to prevent Cross-Site Request Forgery (CSRF).

#### Step 2: The Authorization Response
If the user approves, the AS redirects the browser back to your `redirect_uri` with the code in the URL query string.

**HTTP Redirect:**
```http
HTTP/1.1 302 Found
Location: https://yourapp.com/callback?code=AuthCode123456&state=xyz123random
```

*   **`code`**: A short-lived, one-time-use credential. It usually expires in 1–10 minutes.
*   **`state`**: The same string you sent in Step 1. Your app **must** check that this matches precisely to ensure the request wasn't hijacked.

#### Step 3: The Token Request (Back Channel)
Now, your server (backend) performs a POST request directly to the Token Endpoint. The user does not see this request.

**HTTP POST Request:**
```http
POST /token
Host: oauth2.googleapis.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=AuthCode123456
&redirect_uri=https://yourapp.com/callback
&client_id=YOUR_APP_ID
&client_secret=YOUR_APP_SECRET
```

**Key Parameters:**
*   **`grant_type=authorization_code`**: Defines which flow you are finishing.
*   **`code`**: The code received in the URL in Step 2.
*   **`client_secret`**: The secret password known only to your server and the AS. **This is what authenticates the client.**
*   **`redirect_uri`**: Included again for validation (must match the one used in Step 1).

#### Step 4: The Token Response
The AS verifies the code has not been used yet and that the client secret is correct. It responds with JSON.

**Response:**
```json
{
  "access_token": "AYjcyMzY3ZDhi...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "Rjsu93a...",
  "scope": "read_profile"
}
```

---

### 4. Security Considerations

Why is this complex "Code" swap necessary? Why not just get the token in Step 2?

1.  **Browser Security (Front Channel is unsafe):** URLs are recorded in browser history, proxy logs, and potentially visible to malicious browser extensions. If we sent the Access Token in the URL (like the deprecated Implicit Grant), it could be stolen easily.
2.  **Client Authentication:** By forcing Step 3 (the back-channel swap), the Authorization Server can demand the `client_secret`. This ensures that even if an attacker steals the "Authorization Code" from the browser, they cannot use it because they don't have the `client_secret`.
3.  **Code Injection:** Attackers may try to inject a stolen code into a user's session. This is mitigated by using the `state` parameter (for CSRF protection) and PKCE (Proof Key for Code Exchange—detailed in your Section 10).

### 5. Summary
*   **Input:** User credentials (hosted by AS) + Client ID.
*   **Intermediate:** Authorization Code (exposed in browser URL).
*   **Final Output:** Access Token + Refresh Token (delivered secretly to server).
*   **Best for:** Server-side Web Applications.
