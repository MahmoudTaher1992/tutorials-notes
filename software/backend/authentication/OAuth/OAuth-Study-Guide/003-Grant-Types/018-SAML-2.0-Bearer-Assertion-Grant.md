Based on **Part 3, Item 18** of your study guide, here is a detailed explanation of the **SAML 2.0 Bearer Assertion Grant**.

---

# 018 - SAML 2.0 Bearer Assertion Grant (RFC 7522)

### 1. The High-Level Concept
The **SAML 2.0 Bearer Assertion Grant** flows is a mechanism that acts as a bridge between "Old World" enterprise security (SAML/XML) and "New World" modern API security (OAuth/JSON).

It allows a client to exchange a **SAML 2.0 Assertion** (a security token issued by a traditional Identity Provider like Active Directory Federation Services, Shibboleth, or generic SAML IdPs) for an **OAuth 2.0 Access Token**.

**The Real-World Analogy:**
Imagine you have a voucher (SAML Assertion) from a specific Library proving you are a member. You want to enter a modern Gym (Resource Server), but the Gym only accepts QR codes (Access Tokens). You take your Library voucher to the Gym's front desk (Authorization Server), they verify the Library's signature on the voucher, and hand you a QR code to enter the gym.

### 2. Why do we need this?
SAML (Security Assertion Markup Language) is XML-based and was the standard for enterprise Single Sign-On (SSO) for many years. However, modern APIs and mobile apps prefer OAuth 2.0 (which uses JSON) because XML is heavy and difficult to parse in mobile/browser environments.

**Use Case Scenario:**
1.  **Enterprise Environment:** A user logs into a legacy corporate intranet using ADFS (SAML).
2.  **The Requirement:** The intranet application needs to fetch data for that user from a modern API (e.g., Salesforce, Google Workspace, or a custom internal Microservice) that is protected by OAuth 2.0.
3.  **The Solution:** Instead of asking the user to log in *again* with a password for the API, the application uses the existing SAML token to request an OAuth Access Token silently in the background.

### 3. The Flow Steps

Here is how the exchange happens (assuming the Client already has a SAML Assertion):

1.  **SAML Assertion Generation:** The Client Application obtains a SAML 2.0 Assertion from the Identity Provider (IdP). This assertion proves who the user is.
2.  **Request to Auth Server:** The Client application makes an HTTP POST request to the OAuth **Token Endpoint**.
3.  **Validation:** The Authorization Server (AS) parses the XML Assertion, checks the digital signature (to ensure it came from a trusted IdP), validates the expiration time, and checks the Audience.
4.  **Token Issuance:** If valid, the AS returns an OAuth 2.0 Access Token (and optionally a Refresh Token).
5.  **API Access:** The Client uses the Access Token to call the API.

### 4. The Request Structure

This is the most critical part for a developer. This is a direct call to the generic OAuth token endpoint.

**POST Request to Token Endpoint:**

```http
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn:ietf:params:oauth:grant-type:saml2-bearer
&assertion=PHNhbW...[Base64URL Encoded XML]...
&scope=read_profile
```

**Key Parameters:**
*   **`grant_type`**: Must be exactly `urn:ietf:params:oauth:grant-type:saml2-bearer`. This tells the server, "I am sending you a SAML token."
*   **`assertion`**: The actual SAML 2.0 Assertion XML, derived from the IdP, encoded in **Base64URL** format.
*   **`scope`**: (Optional) The permissions requested.

### 5. SAML Assertion Requirements
For the Authorization Server to accept the SAML token, the XML inside the assertion must meet specific criteria (defined in RFC 7522):

1.  **Issuer (`<Issuer>`):** Must pinpoint the unique identifier of the IdP that created the token.
2.  **Signature:** The assertion must be digitally signed by the IdP. The Authorization Server must have the IdP's public key to verify this signature.
3.  **Subject (`<Subject>`):** Must identify the user (resource owner) on whose behalf the token is being requested.
4.  **Audience (`<Audience>`):** The SAML token must specifically state that it is intended for the Authorization Server (e.g., `https://auth.myapi.com`). If the Audience doesn't match, the AS will reject it to prevent token reuse.
5.  **Conditions (`<Conditions>`):**
    *   `NotOnOrAfter`: The token must not be expired.
    *   `NotBefore`: The token must be currently valid.

### 6. Security Considerations & Trust

*   **No User Interaction:** Notice that in step 2, the generic OAuth login pop-up does not appear. The trust is established entirely via the digital signature on the XML.
*   **Encrypted Transport:** TLS (HTTPS) is mandatory.
*   **Replay Attacks:** Since the assertion is sent as a bearer token in the POST body, the Authorization Server usually tracks the unique ID (`ID` attribute) of the SAML assertion to ensure the same assertion isn't used multiple times to mint new access tokens (One-time use).

### 7. Comparison with JWT Bearer Grant (RFC 7523)
*   **SAML Bearer Grant:** Takes **XML** input, gives **JSON** access token output. (Used when upstream IdP is legacy/SAML).
*   **JWT Bearer Grant:** Takes **JSON (JWT)** input, gives **JSON** access token output. (Used when upstream IdP is modern/OIDC).

### Summary for Implementation
If you are tasked with implementing this:
1.  Ensure your Authorization Server supports RFC 7522.
2.  Configure a trust relationship (exchange certificates) between the SAML IdP and your Authorization Server.
3.  Have your client application encode the XML string into Base64URL without line breaks before sending it to the `/token` endpoint.
