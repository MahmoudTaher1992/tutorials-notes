Based on the Table of Contents you provided, here is a detailed explanation of **Section 10: Authorization Code Grant with PKCE**.

---

# 010 - Authorization Code Grant with PKCE

**PKCE** (pronounced "Pixie") stands for **Proof Key for Code Exchange** (defined in RFC 7636).

It is an extension of the standard Authorization Code flow. While it was originally designed to secure mobile apps and Single Page Applications (SPAs), it is now considered the "Best Practice" for **all** types of OAuth clients in OAuth 2.1.

### 1. The Problem: Why do we need PKCE?

To understand PKCE, you must understand the security hole it fills.

In the standard Authorization Code flow, the process looks like this:
1.  Client asks for code.
2.  Auth Server gives code.
3.  Client swaps code + `client_secret` for a Token.

**The Issue with Public Clients:**
Public clients (like a React app running in a browser or an iOS app running on a phone) cannot store the `client_secret` securely. If you put a secret in a JavaScript app, anyone can view "View Source" and steal it. If you put it in a mobile app, it can be decompiled.

Therefore, public clients used to swap the code for a token **without** a secret.

**The Attack Vector (Authorization Code Interception):**
On mobile devices, apps register Custom URI Schemes (e.g., `myapp://callback`) to receive the Authorization Code. These are not always unique. A malicious app installed on the user's phone could register the same URI scheme.
1.  The legitimate app starts the login.
2.  The Auth Server redirects back to `myapp://callback` with the code.
3.  The **Malicious App** intercepts this redirect, grabs the code, and exchanges it for a token (since no secret is required).

### 2. The Solution: Cryptographic Link

PKCE introduces a dynamic, one-time secret created on the fly for *every single request*. It cryptographically binds the **Authorization Request** (Step 1) to the **Token Request** (Step 2).

Even if a hacker intercepts the Authorization Code, they cannot exchange it for a token because they don't have the secret key generated at the start of the flow.

### 3. Key Concepts: Verifier and Challenge

PKCE relies on two parameters:

1.  **Code Verifier:** A high-entropy random string (password) generated by the client. It acts as the "dynamic secret."
2.  **Code Challenge:** A transformation of the Code Verifier. Usually, this is a SHA-256 hash of the verifier.

### 4. The Flow Steps (in Detail)

Here is how the flow works conceptually:

#### Step A: Client Generates Keys
Before sending the user to the login screen, the Client Application generates a random string called the **Code Verifier**.
*   *Example Verifier:* `50-random-characters-xyz-123...`

The Client then hashes this string to create the **Code Challenge**.
*   *Formula:* `Base64URL(SHA256(Code Verifier))`
*   *Example Challenge:* `mE2kF... (a hashed string)`

#### Step B: Authorization Request (The "Promise")
The Client redirects the user to the Authorization Server. It includes the `code_challenge` in the URL parameters.

```http
GET /authorize?
  response_type=code
  &client_id=my-app
  &redirect_uri=https://myapp/callback
  &scope=read
  &code_challenge=mE2kF...     <-- "I promise I know the secret matching this hash"
  &code_challenge_method=S256
```

The Authorization Server receives this, stores the `code_challenge` temporarily, and links it to the Authorization Code it is about to issue.

#### Step C: The Handshake
The user logs in. The Authorization Server redirects the user back to the client with an **Authorization Code**.

*(Note: If a hacker intercepts the code here, they have the Code, but they do **not** have the original "Code Verifier" string.)*

#### Step D: Token Request (The "Proof")
The Client now wants to swap the Code for an Access Token. It sends the request to the backend, but this time it includes the **original, un-hashed Code Verifier**.

```http
POST /token
  grant_type=authorization_code
  &code=auth_code_from_step_c
  &client_id=my-app
  &redirect_uri=https://myapp/callback
  &code_verifier=50-random-characters-xyz-123...  <-- "Here is the secret"
```

#### Step E: Validation
The Authorization Server receives the request. It performs the following logic:
1.  Takes the received `code_verifier`.
2.  Hashes it using the same method (`S256`).
3.  Compares the result against the `code_challenge` it stored in Step B.

*   **If they match:** The server knows that the client requesting the token is the exact same client that initiated the flow. Token granted.
*   **If they don't match:** The request is rejected.

### 5. Why is this Mandatory in OAuth 2.1?

In the upcoming OAuth 2.1 specification, PKCE is required for **all** clients, not just public ones.

1.  **Code Injection Prevention:** Even for Confidential Clients (which have a `client_secret`), PKCE prevents "Code Injection Attacks" (where an attacker injects a valid stolen authorization code into a legitimate client's session).
2.  **CSRF Protection:** PKCE effectively mitigates Cross-Site Request Forgery (CSRF). While the `state` parameter was traditionally used for this, PKCE provides sufficient protection because an attacker cannot forge the verifier required to complete the flow.
3.  **Simplicity:** It unifies the implementation. Developers don't need to choose between "Implicit Flow" (now deprecated) and standard code flow. Everyone uses Code Flow + PKCE.

### Summary Checklist for Implementation

When implementing this (Item 10 in your study guide), ensure you:
1.  **Use `S256`:** Always use SHA-256 for the challenge method. (The `plain` method exists but should be avoided unless the device cannot calculate a hash).
2.  **Verifier Length:** The verifier must be between 43 and 128 characters long.
3.  **Storage:** The Client must store the `code_verifier` (usually in Session Storage or standard memory) just long enough to complete step D, then delete it.
