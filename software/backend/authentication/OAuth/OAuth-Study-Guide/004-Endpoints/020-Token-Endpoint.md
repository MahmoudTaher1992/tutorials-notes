Based on item **20. Token Endpoint** in your Table of Contents, here is a detailed explanation of what this endpoint is, how it functions, and why it is critical to the OAuth 2.0 and 2.1 architecture.

---

# 20. The Token Endpoint

### 1. Purpose & Behavior
The **Token Endpoint** is the backend engine room of OAuth. While the *Authorization Endpoint* interacts with the user (via the browser) to get permission, the *Token Endpoint* involves a direct, machine-to-machine exchange between the **Client Application** and the **Authorization Server**.

*   **The Goal:** To exchange an authorization artifact (like an Authorization Code) or credentials (like a username/password or client secret) for an **Access Token** (and optionally a Refresh Token or ID Token).
*   **Communication Channel:** This interaction happens on the **Back-Channel**. The user and their browser are **not** involved in this request. It is a direct HTTP call from the Client's server (or device) to the Authorization Server.
*   **Method:** MUST use HTTP **POST**.
*   **Security:** MUST use **HTTPS**. Since sensible data (secrets, tokens) is being transmitted, encryption is mandatory.

---

### 2. Request Parameters by Grant Type
The parameters sent to the Token Endpoint depend on the **Grant Type** being used. The header usually contains `Content-Type: application/x-www-form-urlencoded`.

**Common Parameters:**
*   **`grant_type` (Required):** Tells the server which flow is being used (e.g., `authorization_code`, `client_credentials`, `refresh_token`, `password`).

#### Scenario A: Authorization Code Grant (Most Common)
Used after the user logs in and the browser returns an "Authorization Code."
*   `grant_type`: `authorization_code`
*   `code`: The code received from the Authorization Endpoint.
*   `redirect_uri`: Must be *identical* to the one used in the initial authorization request.
*   `code_verifier`: (If using PKCE) The random string originally generated by the client.

#### Scenario B: Client Credentials Grant
Used for machine-to-machine communication (no user involved).
*   `grant_type`: `client_credentials`
*   `scope`: (Optional) The permissions the server requests for itself.

#### Scenario C: Refresh Token Grant
Used to get a new Access Token when the old one expires.
*   `grant_type`: `refresh_token`
*   `refresh_token`: The refresh token string held by the client.

---

### 3. Client Authentication at Token Endpoint
Since this is a back-channel request, the Authorization Server needs to know *exactly* which client is asking for a token to prevent spoofing.

**Confidential Clients** (Server-side apps) must authenticate using one of these methods:

1.  **Client Secret Basic (Default):** The `client_id` and `client_secret` are combined (`id:secret`), Base64 encoded, and sent in the **Authorization Header**.
    *   `Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2RW`
2.  **Client Secret Post:** The `client_id` and `client_secret` are sent as parameters in the **POST body**.
    *   *Note:* This is considered less secure than Basic Auth due to logging risks.
3.  **Private Key JWT (Advanced):** The client signs a JWT with a private key and sends it to the server. The server verifies it using the client's public key. (Mandatory for Financial-grade APIs).

**Public Clients** (SPA/Mobile apps) cannot store secrets safely. Therefore:
*   They do **not** send a `client_secret`.
*   They **must** use **PKCE** (sending the `code_verifier`) to prove they are the same app that initiated the flow.

---

### 4. Token Response Structure
If the request is valid, the Authorization Server returns a **200 OK** status with a JSON body.

**Standard JSON Response:**
```json
{
  "access_token": "eyJhbGciOiJSUzI1...", // The key to access resources
  "token_type": "Bearer",                // How to use the token
  "expires_in": 3600,                    // Lifetime in seconds
  "refresh_token": "Mw2...al",           // (Optional) Used to get new access tokens
  "scope": "read write",                 // (Optional) The granted scopes
  "id_token": "eyJraWQiOi..."            // (Optional) If using OpenID Connect
}
```

*   **`access_token`:** The credential used to call the API.
*   **`token_type`:** Almost always "Bearer".
*   **`expires_in`:** Implementation tipâ€”clients should calculate `now + expires_in` to know when to stop using the token.
*   **`scope`:** If the server granted fewer scopes than requested (Downscoping), this field is required to inform the client.

---

### 5. Error Responses
If the request fails (e.g., bad password, expired code), the server returns a **400 Bad Request** (or 401 if client authentication failed) with a JSON body.

**Standard Error Codes:**
*   **`invalid_request`:** Missing parameter or malformed request.
*   **`invalid_client`:** Client authentication failed (wrong secret).
*   **`invalid_grant`:** The specific credential provided (Authorization Code or Refresh Token) is invalid, expired, revoked, or used already.
    *   *Tip:* If you see this error, it usually means the Authorization Code was used more than once or timed out.
*   **`unauthorized_client`:** The client is not allowed to use this specific grant type.
*   **`unsupported_grant_type`:** The server doesn't support the requested flow.

### Summary
The **Token Endpoint** is the transactional center of OAuth. It validates the client's identity and their proofs (codes/verifiers), and if satisfied, mints the tokens that allow the application to function. Unlike the Authorization Endpoint, it is designed strictly for software-to-software communication.
