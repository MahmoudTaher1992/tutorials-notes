Based on the Table of Contents you provided, here is a detailed, engineering-focused explanation of section **002-The-Data-Model / 003-Custom-Schemas**.

***

# 002-The-Data-Model / 003-Custom-Schemas

### The Premise
The SCIM protocol comes with a "Core" schema (RFC 7643) that defines standard fields every application understands: `userName`, `emails`, `name`, `active`. It also has an "Enterprise" extension for business fields like `manager` and `costCenter`.

**However**, your specific application is unique.
*   If you are building a **HR App**: You might need `shirtSize` or `parkingSpot`.
*   If you are building a **Streaming Service**: You might need `subscriptionPlan` or `deviceLimit`.
*   If you are building a **Healthcare App**: You might need `primaryWard` or `certificationExpirations`.

None of these exist in standard SCIM. **Custom Schemas** allow you to strictly define these non-standard attributes so Identity Providers (like Okta, Azure AD) can send data into them structured correctly.

---

### 1. The Anatomy of a Custom Schema Extension

To add custom data, you cannot simply throw new keys into the root of the JSON object. SCIM is strict about namespacing to prevent collisions (e.g., if two different extensions both tried to define a field called `status`).

There are three requirements to implement this:

#### A. The Unique Identifier (URN)
You must define a unique URN (Uniform Resource Name) for your extension.
*   **Standard Core URN:** `urn:ietf:params:scim:schemas:core:2.0:User`
*   **Your Custom URN:** `urn:ietf:params:scim:schemas:extension:YourAppName:2.0:User`

#### B. The "Schemas" Array
In every SCIM payload (request or response), there is a `schemas` attribute. You must list your custom URN there to tell the parser: *"Hey, expect data defined by this extension in this payload."*

#### C. The Data "Bucket"
You do not mix custom fields with core fields. You group them inside a JSON object keyed by your Custom URN.

---

### 2. The JSON Payload (What it looks like)

Here is a User resource that contains **Core** data plus **Custom** data for a hypothetical SaaS app called "RocketChat".

```json
{
  "schemas": [
    "urn:ietf:params:scim:schemas:core:2.0:User",
    "urn:ietf:params:scim:schemas:extension:RocketChat:2.0:User"
  ],
  "id": "2819c223...",
  "userName": "bjensen@example.com",
  
  // CORE ATTRIBUTE
  "active": true,

  // CUSTOM EXTENSION BUCKET
  "urn:ietf:params:scim:schemas:extension:RocketChat:2.0:User": {
    "subscriptionTier": "Gold",
    "betaTester": true,
    "coffeePreference": "Espresso"
  }
}
```

**Key Engineering Takeaway:** If you write a parser, you must look for standard fields at the root level, but look for your custom fields *nested* inside the key matching your extension URN.

---

### 3. Defining the Schema (Server-Side)

As the SCIM Server (the Service Provider), you cannot just accept any random JSON. You must define this schema formally so the IdP knows what holds are valid.

You serve this definition at the `/Schemas` endpoint. A definition for a custom attribute includes:

1.  **name:** The key (e.g., `subscriptionTier`).
2.  **type:** The data type. SCIM supports: `string`, `boolean`, `decimal`, `integer`, `dateTime`, `reference`, and `complex` (arrays/objects).
3.  **mutability:** Can this be changed?
    *   `readWrite` (Standard)
    *   `readOnly` (Generated by the server, e.g., `dateCreated`)
    *   `immutable` (Cannot be changed once set, e.g., a legacy ID)
    *   `writeOnly` (e.g., passwords)
4.  **returned:** When is this data returned?
    *   `always`
    *   `default`
    *   `never` (Good for passwords)
5.  **required:** `true` or `false`.

**Example Schema Definition (Abstracted):**
```json
{
  "id": "urn:ietf:params:scim:schemas:extension:RocketChat:2.0:User",
  "name": "RocketChatUser",
  "description": "RocketChat custom user attributes",
  "attributes": [
    {
      "name": "subscriptionTier",
      "type": "string",
      "multiValued": false,
      "required": false,
      "caseExact": false,
      "mutability": "readWrite",
      "returned": "default"
    }
  ]
}
```

---

### 4. How the IdP Uses This

When an Administrator sets up SCIM in Okta, Azure AD, or OneLogin:

1.  **Discovery:** The IdP requests `GET /Schemas` from your API.
2.  **Parsing:** The IdP sees your Custom Schema URN and the attributes (`subscriptionTier`, etc.).
3.  **UI Rendering:** The IdP updates its UI to show these fields as available options.
4.  **Mapping:** The Admin uses the IdP dashboard to map a field from their database (e.g., `user.custom_field_1`) to your SCIM attribute (`urn:...:subscriptionTier`).

### 5. Implementation Gotchas

*   **Validation Errors:** If a client sends a string to an attribute you defined as an integer in your Custom Schema, you must return a standard SCIM Error (Status 400, `scimType: invalidSyntax`).
*   **Complex Types:** Deeply nested JSON in custom schemas is allowed but often poorly supported by older Identity Providers. Keep your custom schema flat if possible.
*   **Case Sensitivity:** Always define if your custom strings are `caseExact`. Does "Gold" equal "gold"? This affects how you write your database queries.
