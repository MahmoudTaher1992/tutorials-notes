Here is the summary of the **OpenTelemetry in Go** deep dive.

***

### Role
I am a **Senior Backend Architect and Go Instructor**. My job is to explain how to build robust, observable systems using Go's strict but powerful environment.

***

### OpenTelemetry in Go: The Study Guide

*   **1. The Core Philosophy of OTel in Go**
    *   **No Magic Agents**
        *   [Unlike Java or Python, Go is compiled and strongly typed, so you cannot "inject" code automatically at runtime.]
        *   **Explicit Compilation**
            *   [You must write the code to instrument your application manually; nothing happens "behind the scenes."]
    *   **The `context.Context` is King**
        *   [This is the standard Go way of managing request scope.]
        *   **Storage**
            *   [The active Span is stored *inside* the Context struct.]
        *   **Immutability**
            *   [You cannot modify a context. When you start a span, Go gives you a **new** context copy containing the span.]
            *   **Propagation Rule**
                *   [You MUST pass this *new* context to the next function to keep the trace alive.]
            *   *Analogy:* [Think of it like a chain letter. To add your name, you don't write on the original paper; you photocopy it, write your name on the copy, and hand that specific copy to the next person. If you hand them the old paper, your name isn't on it.]

*   **2. Manual Wiring (The Setup)**
    *   **The "Big Five" Components**
        *   [Since there is no auto-agent, you must configure these manually in `main.go`.]
        *   1. **Context**: [The background canvas to start everything.]
        *   2. **Exporter**: [Where the data goes, e.g., to a Jaeger collector via gRPC.]
        *   3. **Resource**: [Metadata describing "Who am I?" (e.g., Service Name, Version).]
        *   4. **Processor**: [How to handle data; usually `BatchSpanProcessor` for performance.]
        *   5. **Propagator**: [Translates headers so services can talk to each other (e.g., W3C TraceContext).]
    *   **Initialization Steps**
        *   **Set Global Tracer**: `otel.SetTracerProvider(tp)`
            *   [This allows other libraries (like web frameworks) to find your tracer without you passing it everywhere manually.]
        *   **Cleanup**: `defer shutdown()`
            *   [Always ensure data is flushed (sent out) before the application exits.]

*   **3. Creating Spans (The Coding Pattern)**
    *   **Start and End**
        *   Call `tracer.Start` to begin.
        *   **Always Defer End**: `defer span.End()`
            *   [This ensures the span closes/saves even if your function crashes or errors out.]
    *   **The "Shadowed Context" Trap** (CRITICAL GOTCHA)
        *   **The Mistake**: `_, span := tracer.Start(ctx, ...)`
            *   [Ignoring the returned context breaks the chain. The next function won't know about this span.]
        *   **The Fix**: `ctx, span := tracer.Start(ctx, ...)`
            *   [Always overwrite your `ctx` variable with the new one returned by the tracer.]

*   **4. Concurrency (Goroutines)**
    *   **The Race Condition**
        *   [If a parent function finishes while a child Goroutine is still running, the parent span might close too early, cancelling the child's context.]
    *   **Scenario A: Synchronous (Waiting)**
        *   Use `sync.WaitGroup`.
        *   **Pass the Context**: [Explicitly pass the `ctx` into the Goroutine so the child span links correctly to the parent.]
    *   **Scenario B: Fire-and-Forget (Background Tasks)**
        *   [Example: Sending an email after an HTTP response is sent.]
        *   **Do Not Use Parent Context**
            *   [The parent context will be cancelled when the HTTP request finishes.]
        *   **Use Links**
            *   1. Create a fresh context: `context.Background()`.
            *   2. Extract TraceID from the old context.
            *   3. Create a **Link** to the old trace.
            *   [This creates a new Root Span that references the original request but isn't killed by it.]

*   **5. Library Integration (Middleware)**
    *   **Don't Instrument Everything Manually**
        *   [Use "contrib" libraries for standard operations.]
    *   **HTTP (`otelhttp`)**
        *   [Automatically extracts headers and injects the span into `r.Context()`.]
    *   **SQL (`otelsql`)**
        *   [Wraps the database driver.]
        *   **The Golden Rule**: Use Context Methods.
            *   **Bad**: `db.Query(...)` [The trace stops here because no context is passed.]
            *   **Good**: `db.QueryContext(ctx, ...)` [The trace continues into the database layer.]
