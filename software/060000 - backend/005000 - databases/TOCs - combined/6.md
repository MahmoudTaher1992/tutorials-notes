Combined Table of Contents for Relational Databases

1.  Introduction to Databases
    1.1. What is a Database System (DBMS)?
        1.1.1. Data vs. Information
        1.1.2. Evolution of Database Systems
            1.1.2.1. File-Based Systems (Drawbacks)
            1.1.2.2. Early Data Models (Hierarchical, Network)
            1.1.2.3. Relational Model Emergence (History, Codd's Rules)
            1.1.2.4. Object-Oriented and Object-Relational Models
            1.1.2.5. NoSQL and Other Modern Categories (Context)
        1.1.3. Advantages and Disadvantages of DBMS
        1.1.4. Objectives and Characteristics of DBMS
            1.1.4.1. Data Availability, Integrity, Security, Independence
            1.1.4.2. Reliability, Scalability, Maintainability
            1.1.4.3. ACID Properties (Atomicity, Consistency, Isolation, Durability)
    1.2. Database System Architecture
        1.2.1. ANSI-SPARC Three-Level Architecture
            1.2.1.1. External, Conceptual, Internal Levels
            1.2.1.2. Schemas, Mappings, Instances
            1.2.1.3. Data Independence (Logical, Physical)
        1.2.2. Multi-user DBMS Architectures (Teleprocessing, File-Server, Two-Tier, Three-Tier, N-Tier, Middleware)
        1.2.3. Components and Interfaces of DBMS (Hardware, Software, People, Data Dictionary)
        1.2.4. Roles in the Database Environment (Users, Designers, Administrators)

2.  The Relational Data Model
    2.1. Core Concepts
        2.1.1. Relations and Tables
            2.1.1.1. Attributes and Columns
            2.1.1.2. Tuples and Rows / Records
            2.1.1.3. Domains and Data Types
        2.1.2. Keys
            2.1.2.1. Primary Keys (Natural vs. Surrogate)
            1.1.2.2. Candidate Keys
            2.1.2.3. Superkeys
            2.1.2.4. Foreign Keys
            2.1.2.5. Unique Keys
            2.1.2.6. Composite Keys
        2.1.3. Integrity Constraints
            2.1.3.1. Entity Integrity (Primary Key Constraint)
            2.1.3.2. Referential Integrity (Foreign Key Constraint)
            2.1.3.3. Domain Constraints (Type Constraints, CHECK Constraint)
            2.1.3.4. NOT NULL Constraint
            2.1.3.5. General Database Constraints / Assertions
        2.1.4. Null Values and Incomplete Information (Systematic Treatment)
        2.1.5. Relvars (Relation Variables)
        2.1.6. TABLE_DUM and TABLE_DEE

3.  Database Design and Modeling
    3.1. Database Design Process / Lifecycle
        3.1.1. Phases: Database Planning, Requirements Collection & Analysis
        3.1.2. Conceptual Design
        3.1.3. Logical Design
        3.1.4. Physical Design
        3.1.5. Implementation, Loading, Testing, Maintenance
    3.2. Conceptual Data Modeling
        3.2.1. Entity-Relationship (ER) Model
            3.2.1.1. Entities, Entity Sets, Entity Types
            3.2.1.2. Attributes (Simple, Composite, Multi-valued, Derived, Atomicity)
            3.2.1.3. Relationships (Types, Sets, Roles, Degree, Cardinality, Participation, Recursive)
            3.2.1.4. Strong and Weak Entity Types
            3.2.1.5. Attributes on Relationships
            3.2.1.6. ER Diagrams and Notations (Chen, Crow's Foot)
        3.2.2. Enhanced Entity-Relationship (EER) Model
            3.2.2.1. Subclasses, Superclasses, Inheritance (ISA Relationships)
            3.2.2.2. Specialization and Generalization
            3.2.2.3. Constraints on Specialization/Generalization (Disjoint, Overlap, Total, Partial)
            3.2.2.4. Categories (UNION Types)
            3.2.2.5. Aggregation and Composition
            3.2.2.6. Entity Clusters
            3.2.2.7. Connection Traps (Fan Trap, Chasm Trap)
        3.2.3. UML Class Diagrams (Mapping to ER Concepts)
        3.2.4. Data Collecting, Naming, Grouping (Business Rules)
    3.3. Logical Database Design
        3.3.1. Translation of ER/EER Models to Relational Schemas
        3.3.2. Restructuring ER Schemas (Analysis of Redundancies, Removing Generalizations, Partitioning/Merging)
        3.3.3. Selection of Primary Identifiers
    3.4. Database Design Theory
        3.4.1. Functional Dependencies
            3.4.1.1. Definition, Trivial FDs
            3.4.1.2. Inference Rules (Armstrong's Axioms)
            3.4.1.3. Closure of a Set of FDs, Closure of Attributes
            3.4.1.4. Minimal Cover
        3.4.2. Normalization
            3.4.2.1. Purpose of Normalization (Avoiding Redundancy, Data Anomalies)
            3.4.2.2. First Normal Form (1NF)
            3.4.2.3. Second Normal Form (2NF)
            3.4.2.4. Third Normal Form (3NF)
            3.4.2.5. Boyce-Codd Normal Form (BCNF)
            3.4.2.6. Fourth Normal Form (4NF) (Multivalued Dependencies)
            3.4.2.7. Fifth Normal Form (5NF) (Join Dependencies)
            3.4.2.8. Domain Key Normal Form (DKNF)
            3.4.2.9. Decomposition Properties (Lossless Join, Dependency Preservation)
        3.4.3. Denormalization (Why, When, Basic Types, Algorithm, Tricks)
        3.4.4. Common Database Design Antipatterns (e.g., EAV, Jaywalking, Naive Trees, Polymorphic Associations, Multicolumn Attributes, Metadata Tribbles)
    3.5. Design Documentation and Tools
        3.5.1. Business Rules Documentation
        3.5.2. CASE Tools for Database Design

4.  SQL: The Standard Relational Database Language
    4.1. SQL Fundamentals
        4.1.1. History and Standardization (ANSI, ISO/IEC SQL Standard)
        4.1.2. SQL Command Categories (DDL, DML, DCL, TCL)
        4.1.3. Data Types (Numeric, Character, Date/Time, Boolean, Binary, XML, ROW, Collection, User-Defined/Alias)
        4.1.4. SQL Language Elements (Keywords, Functions, Identifiers, Aliases, Statements, Clauses, Expressions, Predicates, Comments)
    4.2. Data Definition Language (DDL)
        4.2.1. Database and Schema Management (CREATE, ALTER, DROP DATABASE/SCHEMA)
        4.2.2. Table Definition and Modification (CREATE, ALTER, DROP TABLE)
        4.2.3. Specifying Constraints (NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK, ASSERTIONS)
        4.2.4. Index Creation and Management (CREATE, DROP INDEX)
        4.2.5. View Definition and Modification (CREATE, ALTER, DROP VIEW)
            4.2.5.1. Updatable and Nonupdatable Views
            4.2.5.2. Materialized Views
            4.2.5.3. WITH CHECK OPTION
        4.2.6. Sequences
        4.2.7. Synonyms
    4.3. Data Manipulation Language (DML) - Querying Data
        4.3.1. Basic SELECT Statement
            4.3.1.1. SELECT Clause (Columns, Aliases, Expressions, DISTINCT)
            4.3.1.2. FROM Clause (Tables, Table Aliases, Subqueries as Tables)
            4.3.1.3. WHERE Clause (Filtering Rows)
            4.3.1.4. ORDER BY Clause (Sorting Results)
            4.3.1.5. LIMIT / OFFSET / TOP Clause
        4.3.2. Filtering Data
            4.3.2.1. Comparison Operators (=, <>, <, <=, >, >=)
            4.3.2.2. Range Conditions (BETWEEN)
            4.3.2.3. Membership Conditions (IN, NOT IN)
            4.3.2.4. Pattern Matching (LIKE, ILIKE, SIMILAR, Wildcards)
            4.3.2.5. Null Value Checks (IS NULL, IS NOT NULL)
            4.3.2.6. Boolean Logic (AND, OR, NOT)
            4.3.2.7. Quantified Predicates (ALL, SOME, ANY, EXISTS, UNIQUE, OVERLAPS, MATCH)
        4.3.3. Functions
            4.3.3.1. Aggregate Functions (COUNT, SUM, AVG, MAX, MIN, GROUP_CONCAT)
            4.3.3.2. String Functions (CONCAT, SUBSTRING, LENGTH, TRIM, REPLACE, INSERT, REGEXP, UPPER, LOWER)
            4.3.3.3. Numeric Functions (ROUND, TRUNC, MOD, ABS, POWER)
            4.3.3.4. Date/Time Functions (NOW, CURDATE, DATE_ADD, DATEDIFF, DATE_FORMAT, EXTRACT)
            4.3.3.5. Conversion Functions (CAST)
        4.3.4. Grouping and Summarizing Data
            4.3.4.1. GROUP BY Clause
            4.3.4.2. HAVING Clause (Filtering Groups)
            4.3.4.3. ROLLUP, CUBE, GROUPING SETS
        4.3.5. Working with Multiple Tables (Joins)
            4.3.5.1. INNER JOIN
            4.3.5.2. OUTER JOIN (LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN)
            4.3.5.3. CROSS JOIN (Cartesian Product)
            4.3.5.4. NATURAL JOIN, Equijoin, Theta Join
            4.3.5.5. SELF-JOIN
        4.3.6. Subqueries (Nested Queries)
            4.3.6.1. Noncorrelated Subqueries
            4.3.6.2. Correlated Subqueries
            4.3.6.3. Single-Row, Multiple-Row, Multiple-Column Subqueries
            4.3.6.4. Existence Subqueries (EXISTS)
        4.3.7. Set Operations (Combining Multiple Queries)
            4.3.7.1. UNION, UNION ALL
            4.3.7.2. INTERSECT
            4.3.7.3. EXCEPT / MINUS
        4.3.8. Advanced Query Techniques
            4.3.8.1. Common Table Expressions (CTEs, Recursive CTEs)
            4.3.8.2. Window Functions (RANK, DENSE_RANK, NTILE, ROW_NUMBER, LEAD, LAG, FIRST_VALUE, LAST_VALUE)
            4.3.8.3. Pivoting and Unpivoting Data (Crosstab)
            4.3.8.4. Conditional Logic (CASE Expressions, NULLIF, COALESCE)
    4.4. Data Manipulation Language (DML) - Modifying Data
        4.4.1. INSERT Statement (Single Row, Multiple Rows, from SELECT)
        4.4.2. UPDATE Statement (Single Row, Multiple Rows, with Subqueries)
        4.4.3. DELETE Statement (Single Row, Multiple Rows, with Subqueries)
        4.4.4. TRUNCATE TABLE
        4.4.5. MERGE Statement
        4.4.6. SELECT INTO Statement (Copying Table Definitions)
    4.5. Data Control Language (DCL) - Access Control
        4.5.1. User and Role Management (CREATE, DROP USER/ROLE)
        4.5.2. Granting and Revoking Privileges (GRANT, REVOKE, DENY)
        4.5.3. Schema, Table, Column, Row-Level Security
    4.6. SQL Programming
        4.6.1. Embedded SQL and Dynamic SQL
        4.6.2. Stored Procedures and Functions (PL/SQL, T-SQL)
            4.6.2.1. Parameters (IN, OUT, INOUT, Default Values)
            4.6.2.2. Control Structures (IF/ELSE, CASE, LOOP, WHILE, FOR, GOTO)
            4.6.2.3. Variables, Constants, Data Types, Exceptions
        4.6.3. Triggers (BEFORE/AFTER, FOR EACH ROW, INSTEAD OF, DML, DDL, Database Event Triggers)
        4.6.4. Packages (PL/SQL)
        4.6.5. Cursors (Implicit, Explicit, Cursor Variables/REF CURSORs)
        4.6.6. Application Programming Interfaces (ODBC, JDBC, PHP, Python, Java, .NET)

5.  Relational Query Languages Theory
    5.1. Relational Algebra
        5.1.1. Fundamental Operations (Select, Project, Union, Intersection, Difference, Cartesian Product, Rename, Join, Division)
        5.1.2. Extended Operations (Extend, Summarize, Group, Ungroup, Relational Comparisons, Assignment)
        5.1.3. Closure Property
        5.1.4. Evaluating SQL Expressions with Relational Algebra
        5.1.5. Equivalence of Algebraic Expressions
        5.1.6. Algebra with Null Values
    5.2. Relational Calculus
        5.2.1. Tuple Relational Calculus
        5.2.2. Domain Relational Calculus
    5.3. Datalog (Logic-Based Query Language)

6.  Database Storage and Indexing
    6.1. Physical Storage Media
        6.1.1. Memory Hierarchy (Cache, Main Memory, Secondary Storage, Tertiary Storage)
        6.1.2. Magnetic Disks, Flash Storage, Optical Technology
        6.1.3. RAID (Redundant Array of Inexpensive Disks) Levels 0-10
        6.1.4. Data Storage Devices (Factors in Selection)
    6.2. File Structures and Record Organization
        6.2.1. File Organization (Heap File, Sequential File, Hash File, Index File)
        6.2.2. Organization of Records in Files (Fixed/Variable Length, Blocks, Tuples within pages)
        6.2.3. Large Objects Storage (LOBs, BLOBs)
        6.2.4. Data Dictionary Storage
        6.2.5. Tablespaces
    6.3. Indexing Structures
        6.3.1. Types of Indexes (Ordered, B-Tree, B+-Tree, Hash, Bitmap, Functional, Partial, Multicolumn, Unique, Clustered, Nonclustered, Covering, Index-Organized Tables/IOTs)
        6.3.2. Index Creation and Usage (Search Key, Operator Class, Index Selectivity)
        6.3.3. Index Maintenance (Fragmentation, Rebuilding, Updating Statistics)
        6.3.4. Multidimensional Indexes (Grid Files, kd-Trees, R-Trees)

7.  Query Processing and Optimization
    7.1. Query Processor Architecture
        7.1.1. Parsing and Binding (Syntax Analysis, Preprocessor)
        7.1.2. Query Optimization (Generating Candidate Plans, Cost Estimation, Heuristics)
        7.1.3. Query Execution Engine (Operators, Data Access, Aggregations, Joins, Parallelism, Updates)
    7.2. Query Optimization Techniques
        7.2.1. Transformation Rules for Relational Algebra (Algebraic Laws)
        7.2.2. Estimating Statistics of Expression Results (Selectivity, Histograms)
        7.2.3. Choice of Evaluation Plans (Join Order, Join Trees, Pipelining vs. Materialization)
        7.2.4. Cost-Based Optimization (CBO), Query Optimizer Hints/Directives
        7.2.5. Plan Caching and Reuse (Parameter Sniffing, Autoparameterization, Plan Guides, Query Store)
        7.2.6. Physical Database Design for Performance (Indexes, Denormalization, Data Placement)
    7.3. Performance Monitoring and Tuning
        7.3.1. Analyzing Execution Plans (Graphical, XML, Text Plans)
        7.3.2. System Monitoring Tools (Activity Monitor, Performance Counters, DMVs/DMFs, SQL Trace/Extended Events, Query Store)
        7.3.3. Troubleshooting (Blocking, Waits, Deadlocks, Slow Queries, Resource Governor)
        7.3.4. Intelligent Query Processing (Adaptive Joins, Memory Grant Feedback, Interleaved Execution, Columnstore Indexes)
        7.3.5. Tuning Server Settings (Memory, I/O, Concurrency, TempDB)
        7.3.6. Benchmarking

8.  Advanced Database Concepts
    8.1. Distributed Database Systems
        8.1.1. Concepts (Homogeneous, Heterogeneous, Federated, Transparency)
        8.1.2. Distributed Data Storage (Fragmentation, Replication, Allocation)
        8.1.3. Distributed Transactions (Commit Protocols: 2PC, 3PC)
        8.1.4. Distributed Concurrency Control, Deadlock Management, Reliability
        8.1.5. Distributed Query Processing
    8.2. Parallel Databases (Interquery, Intraquery, Interoperation Parallelism)
    8.3. Replication (Leader/Follower, Multi-Leader, Leaderless, Streaming, Synchronous/Asynchronous)
    8.4. Sharding and Data Partitioning (Key Range, Hash of Key, Rebalancing)
    8.5. Cloud Databases (Managed Services, Database-as-a-Service)
    8.6. Data Warehousing
        8.6.1. Concepts (OLTP vs. DW, Characteristics, Benefits)
        8.6.2. Architecture (Operational Data Store, ETL, Metadata)
        8.6.3. Data Modeling (Dimensional Modeling: Star Schema, Snowflake Schema, Fact Tables, Dimension Tables)
        8.6.4. OLAP (Multidimensional Data Model, Data Cube, Slicing, Dicing, Roll-up, Drill-down)
        8.6.5. Data Marts
    8.7. Data Mining
        8.7.1. Concepts and Functionalities (Association Rules, Classification, Clustering, Prediction)
        8.7.2. Data Preprocessing, Task, Query Language
    8.8. Emerging Database Technologies
        8.8.1. Object-Relational Database Extensions (User-Defined Types, Methods, Polymorphism, References, Collections)
        8.8.2. Active Databases (Event-Condition-Action Rules, Triggers)
        8.8.3. XML and JSON Support (Data Model, Schema, Query Languages)
        8.8.4. Temporal Databases
        8.8.5. Spatial and Geographic Databases (PostGIS)
        8.8.6. Mobile Databases
        8.8.7. Multimedia Databases
        8.8.8. Genome Databases
        8.8.9. Internet of Things (IoT) Databases
        8.8.10. Big Data (Hadoop, MapReduce, NoSQL context)

9.  Database Administration and Security
    9.1. Database Administration Tasks
        9.1.1. Installation and Configuration
        9.1.2. Monitoring and Logging
        9.1.3. Backup and Recovery
        9.1.4. Performance Tuning and Optimization
        9.1.5. User and Security Management
        9.1.6. Regular Maintenance (VACUUM, ANALYZE)
        9.1.7. Upgrades and Migrations
    9.2. Database Security
        9.2.1. Security Issues and Threats (SQL Injection, Worms, Data Corruption)
        9.2.2. Authentication (Users, Roles, Passwords, LDAP, SSL)
        9.2.3. Authorization (Privileges, Access Control, Views, Row-Level, Column-Level Security)
        9.2.4. Encryption (Data at Rest, Data in Transit, pgcrypto)
        9.2.5. Auditing (DDL, DML, FGA)
        9.2.6. System Security (Firewalls, Proxy Servers)
        9.2.7. Disaster Recovery
        9.2.8. Compliance and Regulatory Issues

10. Case Studies and Practical Applications
    10.1. Sample Database Applications (e.g., Bus Transport, Hospital, Library, Car Dealer)
    10.2. Specific DBMS Implementations (e.g., Oracle, MySQL, PostgreSQL, SQL Server, DB2, Microsoft Access)
    10.3. Project Development (Front-End, Back-End, Interface)