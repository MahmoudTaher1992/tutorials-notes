Here's a combined Table of Contents (TOC) for relational databases, drawing from the provided sources:

1.  **Introduction to Relational Databases**
    *   **1.1 Core Database Concepts**
        *   1.1.1 What is Data and Information?
        *   1.1.2 What is a Database?
        *   1.1.3 What is a Database Management System (DBMS)?
            *   1.1.3.1 Characteristics and Objectives of DBMS
            *   1.1.3.2 Advantages and Disadvantages of DBMS
        *   1.1.4 History and Evolution of Database Systems
            *   1.1.4.1 File-Based Systems and their Drawbacks
            *   1.1.4.2 Evolution to Relational Model
    *   **1.2 Fundamental Relational Model Terminology**
        *   1.2.1 Relation, Table, Tuple (Row), Attribute (Column)
        *   1.2.2 Domain, Datatype
        *   1.2.3 Schema and Instance
        *   1.2.4 Keys (Superkey, Candidate Key, Primary Key, Foreign Key, Unique Key)
        *   1.2.5 Null Values
    *   **1.3 Relational Model Principles**
        *   1.3.1 Codd's Rules
        *   1.3.2 Properties of Relations
    *   **1.4 Database System Architecture**
        *   1.4.1 DBMS Structure and Components
        *   1.4.2 ANSI/SPARC Three-Schema Architecture
            *   1.4.2.1 External, Conceptual, and Internal Levels
            *   1.4.2.2 Data Independence (Logical and Physical)
        *   1.4.3 Multi-Tier Architectures (Two-Tier, Three-Tier, N-Tier Client-Server)
    *   **1.5 Database Users and Roles**
        *   1.5.1 Data and Database Administrators (DBA)
        *   1.5.2 Database Designers, Application Developers, End-Users

2.  **Relational Data Modeling and Design**
    *   **2.1 Data Modeling Fundamentals**
        *   2.1.1 The Place of Design Theory
        *   2.1.2 Design Steps and Methodologies
        *   2.1.3 Business Rules and Requirements Collection
    *   **2.2 Entity-Relationship (ER) Modeling**
        *   2.2.1 Building Blocks of an ER Diagram
            *   2.2.1.1 Entities and Entity Types
            *   2.2.1.2 Attributes (Simple, Composite, Multi-valued, Derived)
            *   2.2.1.3 Relationships and Relationship Types
        *   2.2.2 Structural Constraints
            *   2.2.2.1 Degree of Relationship (Unary, Binary, Ternary)
            *   2.2.2.2 Cardinality (One-to-One, One-to-Many, Many-to-Many)
            *   2.2.2.3 Participation Constraints (Total, Partial)
        *   2.2.3 Keys in ER Models
            *   2.2.3.1 Primary Keys, Candidate Keys, Foreign Keys (Identifying/Non-identifying)
        *   2.2.4 ER Diagram Notations (e.g., Crow's Foot)
        *   2.2.5 Problems with ER Models (Fan Traps, Chasm Traps)
        *   2.2.6 Enhanced Entity-Relationship (EER) Model
            *   2.2.6.1 Specialization and Generalization (Supertype/Subtype)
            *   2.2.6.2 Attribute Inheritance
            *   2.2.6.3 Constraints on Specialization/Generalization (Disjoint, Overlap, Total, Partial)
            *   2.2.6.4 Aggregation and Composition
            *   2.2.6.5 Entity Clusters
    *   **2.3 Normalization**
        *   2.3.1 Data Redundancy and Anomalies (Insertion, Deletion, Update)
        *   2.3.2 Functional Dependencies
            *   2.3.2.1 Inference Rules (Armstrong's Axioms)
            *   2.3.2.2 Closure of a Set of Attributes/Functional Dependencies, Minimal Cover
        *   2.3.3 Normal Forms
            *   2.3.3.1 First Normal Form (1NF)
            *   2.3.3.2 Second Normal Form (2NF)
            *   2.3.3.3 Third Normal Form (3NF)
            *   2.3.3.4 Boyce-Codd Normal Form (BCNF)
            *   2.3.3.5 Fourth Normal Form (4NF) and Multi-Valued Dependencies
            *   2.3.3.6 Fifth Normal Form (5NF) and Join Dependencies
            *   2.3.3.7 Domain Key Normal Form (DKNF)
        *   2.3.4 Denormalization (When and Why to Denormalize)
    *   **2.4 Logical Database Design**
        *   2.4.1 Translating ER/EER Diagrams to Relational Schemas (Mapping Algorithms)
        *   2.4.2 Documenting Logical Schemas
    *   **2.5 Physical Database Design**
        *   2.5.1 Goals and Steps of Physical Design
        *   2.5.2 File Organization (Heap, Sequential, Hash, Index File)
        *   2.5.3 Data Storage Devices (Magnetic Disks, SSDs, RAID Levels)

3.  **SQL Language: Core Concepts and Usage**
    *   **3.1 Introduction to SQL**
        *   3.1.1 History and Standards (ANSI SQL)
        *   3.1.2 Benefits of Standardized Relational Language
        *   3.1.3 SQL Statement Classes (DDL, DML, DCL, TCL)
        *   3.1.4 SQL Lexical Structure (Keywords, Identifiers, Aliases, Comments, Literals)
    *   **3.2 Data Definition Language (DDL)**
        *   3.2.1 Data Types in SQL (Numeric, Character, Date/Time, Boolean, Large Objects - LOBs/BLOBs/CLOBs, Arrays, JSON/XML, User-Defined Types)
        *   3.2.2 Creating and Managing Databases and Schemas
        *   3.2.3 Creating, Altering, and Dropping Tables
        *   3.2.4 Creating, Altering, and Dropping Views
        *   3.2.5 Creating, Altering, and Dropping Indexes
        *   3.2.6 Table Modification Commands (ADD/MODIFY/DELETE Column, TRUNCATE)
    *   **3.3 Data Manipulation Language (DML)**
        *   3.3.1 Retrieving Data with SELECT Statement
            *   3.3.1.1 SELECT Clause (Columns, Aliases, DISTINCT)
            *   3.3.1.2 FROM Clause (Single/Multiple Tables, Subqueries in FROM, Table Aliases)
            *   3.3.1.3 WHERE Clause (Filtering Rows, Comparison/Logical Operators, BETWEEN, IN, LIKE/ILIKE, NULL handling)
            *   3.3.1.4 GROUP BY Clause (Grouping Data)
            *   3.3.1.5 HAVING Clause (Filtering Groups)
            *   3.3.1.6 ORDER BY Clause (Sorting Results, LIMIT/OFFSET)
            *   3.3.1.7 SQL Functions (Aggregate - COUNT, SUM, AVG, MIN, MAX; String, Numeric, Date/Time, Conversion)
        *   3.3.2 Joining Data from Multiple Tables
            *   3.3.2.1 INNER JOIN
            *   3.3.2.2 OUTER JOIN (LEFT, RIGHT, FULL)
            *   3.3.2.3 CROSS JOIN (Cartesian Product)
            *   3.3.2.4 NATURAL JOIN, USING Clause
            *   3.3.2.5 SELF JOIN
        *   3.3.3 Combining Query Results with Set Operations
            *   3.3.3.1 UNION, UNION ALL
            *   3.3.3.2 INTERSECT
            *   3.3.3.3 EXCEPT (MINUS)
        *   3.3.4 Subqueries (Nested Queries)
            *   3.3.4.1 Single-Row, Multiple-Row, Multiple-Column Subqueries
            *   3.3.4.2 Correlated Subqueries, EXISTS Operator
        *   3.3.5 Common Table Expressions (CTEs)
            *   3.3.5.1 Recursive CTEs
        *   3.3.6 Changing Data
            *   3.3.6.1 INSERT Statement (Adding New Rows, INSERT...SELECT)
            *   3.3.6.2 UPDATE Statement (Modifying Existing Rows)
            *   3.3.6.3 DELETE Statement (Removing Rows)
            *   3.3.6.4 MERGE Statement
    *   **3.4 Data Control Language (DCL)**
        *   3.4.1 User Management
        *   3.4.2 Granting and Revoking Privileges (Object, System)
        *   3.4.3 Creating and Managing Roles

4.  **Advanced SQL and Database Programming**
    *   **4.1 Integrity Constraints in Detail**
        *   4.1.1 Entity Integrity (Primary Key Constraint)
        *   4.1.2 Domain Integrity (Data Type, NOT NULL, CHECK Constraint, Domains)
        *   4.1.3 Referential Integrity (Foreign Key Constraint, ON DELETE/UPDATE CASCADE/SET NULL)
        *   4.1.4 Assertions (General Constraints)
    *   **4.2 Advanced Views**
        *   4.2.1 Updatable Views
        *   4.2.2 Views from Multiple Tables / Views from Views
        *   4.2.3 Materialized Views (Snapshot)
        *   4.2.4 Views with CHECK OPTION / Read-only Option
    *   **4.3 Procedural SQL (PL/SQL, T-SQL, PSM)**
        *   4.3.1 Structure of PL/SQL Blocks
        *   4.3.2 Variables and Constants (Declarations, %TYPE, %ROWTYPE)
        *   4.3.3 Control Structures (IF-THEN-ELSE, CASE, LOOP, WHILE, FOR)
        *   4.3.4 Cursors (Implicit, Explicit, Cursor Attributes, REF CURSORs)
        *   4.3.5 Stored Procedures and Functions (Parameters, Overloading, Recursion)
        *   4.3.6 Packages (Specification, Body, Initializing, Global Data)
        *   4.3.7 Triggers (DML, DDL, Database Events; BEFORE/AFTER, FOR EACH ROW, INSTEAD OF)
        *   4.3.8 Exception Handling (Predefined, User-Defined, RAISE, RAISE_APPLICATION_ERROR)
        *   4.3.9 Dynamic SQL (EXECUTE IMMEDIATE, OPEN FOR)
    *   **4.4 Embedded SQL and APIs**
        *   4.4.1 Embedded SQL (Host Variables, Cursors)
        *   4.4.2 Call-Level Interfaces (CLI): JDBC, ODBC
    *   **4.5 Advanced Data Types and Features**
        *   4.5.1 Object-Relational Database Features (Row Types, User-Defined Types, Subtypes/Supertypes, Reference Types)
        *   4.5.2 Temporal Data Management (Date/Time Functions, Intervals)
        *   4.5.3 XML and JSON Support in SQL
        *   4.5.4 Analytic (Window) Functions (Ranking, Lag/Lead, Moving Averages)
        *   4.5.5 User-Defined Data Types and Domains

5.  **Database Administration, Performance, and Maintenance**
    *   **5.1 Transaction Management**
        *   5.1.1 Transaction Concept
        *   5.1.2 ACID Properties (Atomicity, Consistency, Isolation, Durability)
        *   5.1.3 Transaction States, Savepoints
        *   5.1.4 Concurrency Control
            *   5.1.4.1 Serializability (Conflict, View)
            *   5.1.4.2 Lock-Based Protocols (Two-Phase Locking - 2PL, Granularity, Update Locks)
            *   5.1.4.3 Timestamp-Based Protocols
            *   5.1.4.4 Validation-Based (Optimistic) Protocols
            *   5.1.4.5 Deadlock Management (Detection, Prevention, Avoidance)
        *   5.1.5 Isolation Levels (Read Uncommitted, Read Committed, Repeatable Read, Snapshot Isolation, Serializable)
    *   **5.2 Database Recovery**
        *   5.2.1 Failure Classification (Transaction, System, Media Failure)
        *   5.2.2 Storage Structure (Volatile, Nonvolatile, Stable Storage)
        *   5.2.3 Recovery Mechanisms (Logging - Undo/Redo, Write-Ahead Log)
        *   5.2.4 Checkpointing
        *   5.2.5 Backup and Restore Procedures
    *   **5.3 Performance Tuning and Optimization**
        *   5.3.1 Query Processing
            *   5.3.1.1 Query Decomposition, Heuristics
            *   5.3.1.2 Query Evaluation Plans, Query Plan Operators
        *   5.3.2 Query Optimization
            *   5.3.2.1 Cost-Based Optimization
            *   5.3.2.2 Execution Plans (Graphical, XML, Text), Analyzing Plans
            *   5.3.2.3 Statistics (Collection, Histograms, Cardinality Estimation)
            *   5.3.2.4 Query Optimizer Hints/Directives
            *   5.3.2.5 Plan Caching, Parameter Sniffing
        *   5.3.3 Indexing for High Performance
            *   5.3.3.1 Types of Indexes (B-Tree, Hash, Clustered, Nonclustered, Covering, Filtered, Composite, Partial, Functional, Bitmap)
            *   5.3.3.2 Index Design Considerations and Best Practices
            *   5.3.3.3 Index Maintenance (Rebuilding, Fragmentation)
        *   5.3.4 Server and Hardware Optimization
            *   5.3.4.1 Database Configuration Tuning (Memory, I/O, Concurrency Settings)
            *   5.3.4.2 Operating System and Hardware Selection/Tuning
            *   5.3.4.3 Data Storage Management (RAID, Filegroups, Tablespaces)
        *   5.3.5 Memory and I/O Tuning
        *   5.3.6 Denormalization for Performance
    *   **5.4 Database Security**
        *   5.4.1 Security Goals and Threats
        *   5.4.2 Authorization and Access Control (GRANT/REVOKE, Roles, Views)
        *   5.4.3 Row-Level Security
        *   5.4.4 Data Encryption (at rest, in transit)
        *   5.4.5 Auditing and Logging
        *   5.4.6 SQL Injection Prevention
    *   **5.5 Monitoring and Troubleshooting**
        *   5.5.1 Analyzing Wait Statistics
        *   5.5.2 Detecting Blocking and Deadlocks
        *   5.5.3 Performance Counters, Dynamic Management Views (DMVs)
        *   5.5.4 Query Store, Extended Events, SQL Trace/Profiler
        *   5.5.5 Alerting and Logging
    *   **5.6 Database Maintenance and Management Tools**
        *   5.6.1 Regular Maintenance (VACUUM, ANALYZE)
        *   5.6.2 Database Upgrades and Migrations

6.  **Advanced Database Systems and Concepts**
    *   **6.1 Distributed Databases**
        *   6.1.1 Distributed DBMS Architecture
        *   6.1.2 Data Fragmentation (Horizontal, Vertical)
        *   6.1.3 Data Replication (Synchronous, Asynchronous, Multi-leader)
        *   6.1.4 Data Allocation Strategies
        *   6.1.5 Distributed Query Processing and Optimization
        *   6.1.6 Distributed Concurrency Control and Recovery (Two-Phase Commit - 2PC)
        *   6.1.7 Sharding / Horizontal Partitioning
    *   **6.2 Data Warehousing and Business Intelligence**
        *   6.2.1 Data Warehousing Concepts and Architecture
        *   6.2.2 Dimensional Modeling (Star Schema, Snowflake Schema, Fact Tables, Dimension Tables)
        *   6.2.3 Online Analytical Processing (OLAP)
            *   6.2.3.1 Multidimensional Data Model (Cubes, Slicing, Dicing, Roll-up, Drill-down)
        *   6.2.4 Data Mining (Classification, Clustering, Association Rules)
    *   **6.3 Specialized Database Systems**
        *   6.3.1 Geographic Information Systems (GIS) and Spatial Databases
        *   6.3.2 Multimedia Databases
        *   6.3.3 Temporal Databases (Application-Time, System-Versioned, Bitemporal)
        *   6.3.4 XML and JSON Databases / Support within RDBMS
        *   6.3.5 Object-Relational DBMS (ORDBMS)
    *   **6.4 Cloud-Based Relational Databases**
        *   6.4.1 SQL Azure / DocumentDB (Managed Services)
        *   6.4.2 Cloud-Specific Design and Optimization Considerations
    *   **6.5 Application Development and Integration**
        *   6.5.1 Object-Relational Mapping (ORM) frameworks (e.g., Hibernate)
        *   6.5.2 Database Design Tools (CASE tools)
        *   6.5.3 Database Programming Environments and Frameworks