Here's a comprehensive, combined Table of Contents for Relational Databases, structured in a tree-view format with at least 3 levels, drawing from the provided sources:

---

**Relational Databases: Combined Table of Contents**

1.  **Introduction to Database Systems**
    1.1.  **Overview of Databases**
        1.1.1.  Data and Information Concepts
        1.1.2.  What is a Database?
        1.1.3.  What is a Database Management System (DBMS)?
        1.1.4.  Characteristics and Objectives of DBMS
            1.1.4.1.  Data Availability
            1.1.4.2.  Data Integrity and Consistency
            1.1.4.3.  Data Security
            1.1.4.4.  Data Independence (Logical & Physical)
            1.1.4.5.  Centralized Data Management
        1.1.5.  Advantages and Disadvantages of DBMS
    1.2.  **Evolution of Database Systems**
        1.2.1.  Traditional File-Based Systems (Drawbacks)
        12.2.  Early Database Models (Hierarchical, Network)
        1.2.3.  History of the Relational Model
        1.2.4.  Object and Object-Relational Models
        1.2.5.  NoSQL and Other Database Categories (Brief Comparison)
    1.3.  **Database System Architecture**
        1.3.1.  ANSI-SPARC Three-Schema Architecture (External, Conceptual, Internal Levels)
        1.3.2.  Multi-Tier Architectures (Two-Tier, Three-Tier, N-Tier Client-Server)
        1.3.3.  Components and Interfaces of DBMS (Hardware, Software, Data, Procedure, People, Data Dictionary)
        1.3.4.  DBMS Vendors and Products (Overview)
    1.4.  **Roles in the Database Environment**
        1.4.1.  Data and Database Administrators (DBA)
        1.4.2.  Database Designers
        1.4.3.  Application Developers
        1.4.4.  End-Users
    1.5.  **Database Languages**
        1.5.1.  Data Definition Language (DDL)
        1.5.2.  Data Manipulation Language (DML)
        1.5.3.  Data Control Language (DCL)
        1.5.4.  Fourth-Generation Languages (4GLs)

2.  **Relational Model Fundamentals**
    2.1.  **Core Concepts**
        2.1.1.  What is the Relational Model? (Definition, Objectives, Principles)
        2.1.2.  Relations and Tables (Structure, Properties)
        2.1.3.  Tuples (Rows)
        2.1.4.  Attributes (Columns)
        2.1.5.  Domains and Types (Scalar vs. Nonscalar, Atomicity)
        2.1.6.  Values and Variables
        2.1.7.  Importance of Relvars (Relation Variables)
        2.1.8.  Why Duplicate Tuples and Nulls Are Prohibited (in Pure Relational Model)
        2.1.9.  CODD's 12 Rules
    2.2.  **Relational Integrity Constraints**
        2.2.1.  Keys
            2.2.1.1.  Superkey
            2.2.1.2.  Candidate Key
            2.2.1.3.  Primary Key (Conventions, Tailoring to Fit)
            2.2.1.4.  Alternate (Unique) Key
            2.2.1.5.  Foreign Key (Referential Constraints)
        2.2.2.  Entity Integrity
        2.2.3.  Domain Integrity (Type Constraints)
        2.2.4.  Referential Integrity
        2.2.5.  General Database Constraints (Assertions, Check Constraints)
    2.3.  **Formal Relational Query Languages**
        2.3.1.  Relational Algebra
            2.3.1.1.  Closure Property
            2.3.1.2.  Fundamental Operators (Union, Intersection, Difference, Cartesian Product, Selection, Projection, Rename, Join, Division)
            2.3.1.3.  Extended Operators (Extend, Summarize, Group, Ungroup)
            2.3.1.4.  Advantages and Limitations
        2.3.2.  Relational Calculus
            2.3.2.1.  Tuple Relational Calculus
            2.3.2.2.  Domain Relational Calculus
        2.3.3.  Datalog (Introduction, Recursion)
        2.3.4.  Query-by-Example (QBE)

3.  **Conceptual Database Design**
    3.1.  **The Database Design Process** (Lifecycle, Methodologies)
    3.2.  **Requirements Collection and Analysis**
        3.2.1.  Understanding Business Rules and Objectives
        3.2.2.  Fact-Finding Techniques (Interviews, Document Gathering, Observation)
        3.2.3.  Data Collection Strategies (Avoiding Reports/Screens, Identifying Boundaries)
    3.3.  **Entity-Relationship (ER) Modeling**
        3.3.1.  Basic Constructs (Entities, Attributes, Relationships)
        3.3.2.  ER Diagrams (Representation, Naming Conventions)
        3.3.3.  Entity Types and Sets
            3.3.3.1.  Strong and Weak Entities
        3.3.4.  Attribute Classification (Simple, Composite, Multi-valued, Derived)
        3.3.5.  Relationship Types and Sets
            3.3.5.1.  Degree of Relationship (Unary, Binary, Ternary, Quaternary)
            3.3.5.2.  Multiplicity (Cardinality) & Participation Constraints (One-to-One, One-to-Many, Many-to-Many)
            3.3.5.3.  Recursive Relationships
            3.3.5.4.  Attributes on Relationships
        3.3.6.  Modeling Constraints (Identification, Unique Identifier, Arcs)
        3.3.7.  Problems with ER Models (Fan Traps, Chasm Traps)
        3.3.8.  Enhanced Entity-Relationship (EER) Modeling
            3.3.8.1.  Subclasses, Superclasses, Inheritance
            3.3.8.2.  Specialization and Generalization (Constraints on)
            3.3.8.3.  Aggregation and Composition
            3.3.8.4.  Entity Clusters
    3.4.  **Data Modeling with UML Class Diagrams**
        3.4.1.  Mapping ER to UML
    3.5.  **Modeling Change and Time** (Temporal Data)
    3.6.  **Advanced Modeling Topics** (Patterns, Hierarchies, Generic Modeling)
    3.7.  **CASE Tools for Database Design**

4.  **Relational Database Design Theory & Normalization**
    4.1.  **Data Redundancy and Anomalies**
        4.1.1.  Problems of Redundancy (Insertion, Deletion, Update Anomalies)
    4.2.  **Functional Dependencies (FD)**
        4.2.1.  Definition and Characteristics
        4.2.2.  Inference Rules (Armstrong's Axioms)
        4.2.3.  Closure of Functional Dependencies (Set of Attributes)
        4.2.4.  Minimal Cover
    4.3.  **Normal Forms**
        4.3.1.  Purpose of Normalization
        4.3.2.  Steps in Normalization
        4.3.3.  First Normal Form (1NF)
        4.3.4.  Second Normal Form (2NF)
        4.3.5.  Third Normal Form (3NF)
        4.3.6.  Boyce-Codd Normal Form (BCNF)
        4.3.7.  Multivalued Dependencies (MVD) and Fourth Normal Form (4NF)
        4.3.8.  Join Dependencies (JD) and Fifth Normal Form (5NF)
        4.3.9.  Domain Key Normal Form (DKNF)
    4.4.  **Decomposition Properties** (Lossless Join, Dependency Preservation)
    4.5.  **Relational Database Design Algorithms**
    4.6.  **Denormalization** (When and Why, Techniques, Trade-offs)
    4.7.  **SQL Antipatterns (Logical Design Antipatterns)**
        4.7.1.  Jaywalking (Comma-Separated Lists)
        4.7.2.  Naive Trees (Adjacency List)
        4.7.3.  Keyless Entry (Missing Constraints)
        4.7.4.  Entity-Attribute-Value (Generic Attribute Tables)
        4.7.5.  Polymorphic Associations (Dual-Purpose Foreign Keys)
        4.7.6.  Multicolumn Attributes (Repeating Columns)
        4.7.7.  Metadata Tribbles (Cloning Tables/Columns)

5.  **Structured Query Language (SQL)**
    5.1.  **SQL Fundamentals**
        5.1.1.  History and ANSI Standards
        5.1.2.  SQL Terms and Lexical Structure (Keywords, Identifiers, Aliases, Comments)
        5.1.3.  SQL Datatypes
            5.1.3.1.  Numeric (Integer, Decimal, Float, Serial)
            5.1.3.2.  Character (CHAR, VARCHAR, NCHAR, NVARCHAR, CLOB)
            5.1.3.3.  Temporal (DATE, TIME, TIMESTAMP, INTERVAL)
            5.1.3.4.  Boolean
            5.1.3.5.  Binary (BLOB)
            5.1.3.6.  Composite and User-Defined Types
            5.1.3.7.  Null Values (Systematic Treatment, Three-Valued Logic)
        5.1.4.  SQL Commands Overview
    5.2.  **Data Definition Language (DDL)**
        5.2.1.  Creating and Deleting Databases/Schemas
        5.2.2.  Creating Tables (Specifying Columns, Constraints, Defaults)
        5.2.3.  Modifying Table Structure (ALTER TABLE - Add, Modify, Drop Columns)
        5.2.4.  Truncating and Dropping Tables/Indexes
    5.3.  **Data Manipulation Language (DML)**
        5.3.1.  Inserting Data (INSERT INTO, Default Values, Subqueries, Multiple Rows)
        5.3.2.  Updating Data (UPDATE, Multiple Rows, Correlated Subqueries, Values from Other Tables)
        5.3.3.  Deleting Data (DELETE FROM, Specific Records, All Records, Referential Integrity Violations)
        5.3.4.  MERGE Statement
    5.4.  **Data Retrieval (SELECT Statement)**
        5.4.1.  Basic SELECT Syntax (FROM, WHERE)
        5.4.2.  Selecting All or Subset of Columns
        5.4.3.  Column Aliases
        5.4.4.  Removing Duplicates (DISTINCT)
        5.4.5.  Filtering Rows (WHERE Clause)
            5.4.5.1.  Comparison Operators (=, <>, <, >, <=, >=)
            5.4.5.2.  Range Conditions (BETWEEN)
            5.4.5.3.  Membership Conditions (IN, NOT IN)
            5.4.5.4.  Pattern Matching (LIKE, ILIKE, SIMILAR, REGEXP)
            5.4.5.5.  Null Conditions (IS NULL, IS NOT NULL)
            5.4.5.6.  Boolean/Logical Operators (AND, OR, NOT, Parentheses)
        5.4.6.  Sorting Query Results (ORDER BY, Multiple Columns, Expressions, Nulls)
        5.4.7.  Limiting Results (LIMIT, OFFSET, TOP N)
    5.5.  **Functions and Expressions**
        5.5.1.  Aggregate Functions (COUNT, SUM, AVG, MIN, MAX, GROUP_CONCAT)
        5.5.2.  Grouping Data (GROUP BY, Multiple Columns)
        5.5.3.  Filtering Groups (HAVING Clause)
        5.5.4.  Single-Row / Scalar Functions
            5.5.4.1.  Character Functions (UPPER, LOWER, INITCAP, SUBSTR, LENGTH, TRIM, REPLACE, CONCAT)
            5.5.4.2.  Numeric Functions (ROUND, TRUNC, MOD, ABS, POWER)
            5.5.4.3.  Date/Time Functions (NOW, CURDATE, DATE_ADD, DATEDIFF, EXTRACT, DATE_FORMAT)
            5.5.4.4.  Conversion Functions (CAST, TO_CHAR, TO_NUMBER, TO_DATE)
            5.5.4.5.  Null Functions (NVL, COALESCE, NULLIF)
        5.5.5.  Value Expressions (Numeric, String, Datetime, Interval, Conditional, Row Value)
        5.5.6.  Conditional Logic (CASE Expression - Simple, Searched)
    5.6.  **Joins and Set Operations**
        5.6.1.  Joining Multiple Tables
            5.6.1.1.  Cartesian Product (CROSS JOIN)
            5.6.1.2.  Inner Joins (EQUIJOIN, NATURAL JOIN, Condition Join)
            5.6.1.3.  Outer Joins (LEFT, RIGHT, FULL OUTER)
            5.6.1.4.  Self-Joins
            5.6.1.5.  Join Conditions vs. Filter Conditions (ON vs. WHERE)
        5.6.2.  Set Operators (UNION, UNION ALL, INTERSECT, EXCEPT / MINUS)
    5.7.  **Subqueries (Nested Queries)**
        5.7.1.  Types of Subqueries (Single-Row, Multiple-Row, Multiple-Column, Correlated)
        5.7.2.  Subqueries in SELECT, FROM, WHERE, HAVING Clauses
        5.7.3.  Subqueries with EXISTS and NOT EXISTS
        5.7.4.  Quantified Subqueries (ANY, SOME, ALL)
        5.7.5.  Data Manipulation Using Subqueries
    5.8.  **Views**
        5.8.1.  What is a View? (Virtual Tables)
        5.8.2.  Creating, Altering, Dropping Views
        5.8.3.  Benefits of Views (Security, Aggregation, Hiding Complexity)
        5.8.4.  Updatable Views (Simple, Complex, INSTEAD OF Triggers, WITH CHECK OPTION)
        5.8.5.  Materialized Views (Indexed Views)
        5.8.6.  Inline Views
    5.9.  **Advanced Querying Concepts**
        5.9.1.  Common Table Expressions (CTE) (Recursive, Hierarchical Queries)
        5.9.2.  Window Functions (Partition By, Order By, Ranking Functions, Lag/Lead, Moving Averages, Running Totals)
        5.9.3.  Pivoting and Unpivoting Data (Crosstabs)
        5.9.4.  SQL Antipatterns (Query Antipatterns)
            5.9.4.1.  Fear of the Unknown (Null as Ordinary Value)
            5.9.4.2.  Ambiguous Groups (Nongrouped Columns)
            5.9.4.3.  Random Selection (Sorting Data Randomly)
            5.9.4.4.  Poor Man's Search Engine (Pattern Matching Predicates)
            5.9.4.5.  Spaghetti Query (Complex Problem in One Step)
            5.9.4.6.  Implicit Columns (Shortcut Typing)

6.  **SQL Programming & Advanced Features**
    6.1.  **Stored Routines**
        6.1.1.  Stored Procedures (Creating, Parameters - IN/OUT/INOUT, Executing, Modifying, Deleting)
        6.1.2.  Stored Functions (Creating, Returning Value, Modifying, Deleting)
        6.1.3.  Packages (Specification, Body, Initializing, Global Data, Encapsulation, Logical Grouping)
    6.2.  **Procedural Control Statements (PL/SQL, T-SQL, PSM)**
        6.2.1.  Block Structure (Anonymous, Named, Nested)
        6.2.2.  Variables (Declaring, Assigning, %TYPE, %ROWTYPE, Collections)
        6.2.3.  Conditional Control (IF-THEN-ELSE, CASE)
        6.2.4.  Iterative Control (LOOP, WHILE, FOR, CONTINUE, EXIT)
        6.2.5.  Sequential Control (GOTO, NULL Statement)
        6.2.6.  Collections (Associative Arrays, Nested Tables, Varrays, Methods)
        6.2.7.  Records
    6.3.  **Cursors**
        6.3.1.  What is a Cursor? (Implicit, Explicit)
        6.3.2.  Declaring, Opening, Fetching, Closing Cursors
        6.3.3.  Cursor Attributes (%FOUND, %NOTFOUND, %ISOPEN, %ROWCOUNT)
        6.3.4.  Positioned UPDATE and DELETE Statements (WHERE CURRENT OF)
        6.3.5.  Cursor Variables (REF CURSORs)
        6.3.6.  Scrolling Cursors
    6.4.  **Triggers**
        6.4.1.  What is a Trigger? (Events, Action Time, Triggered SQL)
        6.4.2.  Creating, Altering, Dropping Triggers
        6.4.3.  Types of Triggers (DML, DDL, Logon, Instead Of, Compound, Autonomous)
        6.4.4.  Referencing Old and New Values
        6.4.5.  Nested and Recursive Triggers
        6.4.6.  Trigger Management and Maintenance
    6.5.  **Dynamic SQL**
        6.5.1.  When to Use Dynamic SQL
        6.5.2.  EXECUTE IMMEDIATE Statement
        6.5.3.  Binding Variables
        6.5.4.  OPEN FOR Statement
        6.5.5.  DBMS_SQL Package
    6.6.  **Error and Exception Handling**
        6.6.1.  SQLSTATE and SQLCODE
        6.6.2.  Predefined and User-Defined Exceptions
        6.6.3.  Raising and Propagating Exceptions (RAISE, RAISE_APPLICATION_ERROR)
        6.6.4.  Exception Handlers (TRY...CATCH, WHEN OTHERS)
        6.6.5.  Compile-Time Warnings
    6.7.  **SQL and External Programming Languages / Frameworks**
        6.7.1.  Integration Problems (Impedance Mismatch)
        6.7.2.  Embedded SQL (Host Variables)
        6.7.3.  Module Language
        6.7.4.  Call-Level Interfaces (ODBC, JDBC, SQL/CLI)
        6.7.5.  Object-Relational Mappers (ORM) (Hibernate)
        6.7.6.  Web Database Programming (PHP, Java, .NET)
    6.8.  **XML and JSON Support**
        6.8.1.  XML Data Type (Storing, Querying, Functions - XMLELEMENT, XMLAGG, XQUERY)
        6.8.2.  JSON Data Type (Storing, Querying, Functions, Path Language)
    6.9.  **Physical Database Design Antipatterns**
        6.9.1.  Rounding Errors (FLOAT vs NUMERIC)
        6.9.2.  31 Flavors (Values in Column Definition)
        6.9.3.  Phantom Files (Storing Bulky Media)
        6.9.4.  Index Shotgun (Indexes Without a Plan)

7.  **Database Administration & Management**
    7.1.  **Configuration and Settings**
        7.1.1.  Server Parameters (postgresql.conf, my.cnf, SQL Server Configuration)
        7.1.2.  Memory Settings (Buffer Pool, Shared Pool, PGA)
        7.1.3.  I/O Settings
        7.1.4.  Network Configuration
        7.1.5.  Database File Layout (Filegroups, Tablespaces)
    7.2.  **User and Security Management**
        7.2.1.  Creating/Deleting Users and Roles
        7.2.2.  Granting/Revoking Privileges
        7.2.3.  Managing Passwords
        7.2.4.  Auditing DDL and Data Changes
        7.2.5.  Connection Access Control (pg_hba.conf, Firewall Rules)
    7.3.  **Monitoring and Diagnosis**
        7.3.1.  System Catalog Views (pg_stat_activity, sys.dm_exec_requests)
        7.3.2.  Performance Schema (MySQL)
        7.3.3.  Log Files (Server Logs, Alert Logs)
        7.3.4.  Hardware/OS Monitoring (CPU, Memory, Disk I/O, Network)
        7.3.5.  Troubleshooting (Blocking, Deadlocks, Slow Queries, Resource Contention)
        7.3.6.  Query Store (SQL Server)
        7.3.7.  Extended Events (SQL Server)
    7.4.  **Regular Maintenance**
        7.4.1.  Automatic Database Maintenance (VACUUM, autovacuum)
        7.4.2.  Index Maintenance (Rebuilding, Reorganizing, Updating Statistics)
        7.4.3.  Table Maintenance (Identifying/Fixing Bloated Tables)
        7.4.4.  Transaction Wraparound Protection
        7.4.5.  Planning Maintenance Tasks

8.  **Performance Tuning & Optimization**
    8.1.  **Query Performance Optimization**
        8.1.1.  Query Processor Architecture (Parsing, Binding, Optimization, Execution)
        8.1.2.  Understanding Query Cost (Measures of Cost, Execution Plans - EXPLAIN)
        8.1.3.  Identifying Slow Queries (SQL Trace, Profiler, Query Store)
        8.1.4.  Rewriting and Restructuring Queries
            8.1.4.1.  Avoiding Full Table Scans
            8.1.4.2.  Simplifying Complex Queries (Divide and Conquer)
            8.1.4.3.  Optimizing Joins (Order, Type)
            8.1.4.4.  Optimizing Subqueries (Uncorrelating)
            8.1.4.5.  Efficient Use of Aggregates and Grouping
            8.1.4.6.  Avoiding Unnecessary Operations
        8.1.5.  Query Optimizer Hints/Directives (INDEX, FORCE ORDER)
        8.1.6.  Parameter Sniffing and Optimization for Ad Hoc Workloads
        8.1.7.  Cardinality Estimation
    8.2.  **Indexing for High Performance**
        8.2.1.  Types of Indexes (Clustered, Nonclustered, Unique, Composite, Covering, Functional, Partial, Bitmap, Hash, B-Tree, B+ Tree, GIN/GiST)
        8.2.2.  Index Selectivity
        8.2.3.  Designing Optimal Indexes (Column Order, Multicolumn, Prefix)
        8.2.4.  When to Use and Avoid Indexes (Costs, Fragmentation)
        8.2.5.  Missing and Unused Index Detection
    8.3.  **Database Server & Hardware Tuning**
        8.3.1.  Operating System and Hardware Optimization (CPU, Memory, Disk, Network)
        8.3.2.  Memory Tuning (Buffer Cache, Shared Pool, PGA)
        8.3.3.  I/O Tuning (Disk Striping, RAID Levels, Asynchronous I/O)
        8.3.4.  Caching Mechanisms (Query Result Cache, Client-Side Cache)
    8.4.  **Advanced Optimization Techniques**
        8.4.1.  Intelligent Query Processing (Adaptive Joins, Memory Grant Feedback, Interleaved Execution)
        8.4.2.  Column-Oriented Storage (Columnstore Indexes)
        8.4.3.  In-Memory OLTP (Memory-Optimized Tables, Natively Compiled Stored Procedures)
        8.4.4.  Partitioning (Table Partitioning, Index Partitioning, Horizontal Sharding)
        8.4.5.  Materialized Views for Query Rewriting
        8.4.6.  Expression Transformation

9.  **Data Storage, Indexing & File Structures**
    9.1.  **Physical Storage Media**
        9.1.1.  Memory Hierarchy (Volatile and Nonvolatile Storage)
        9.1.2.  Magnetic Disks (Mechanics, Controller, Access Characteristics)
        9.1.3.  Flash Storage (SSD)
        9.1.4.  Tertiary Storage
        9.1.5.  RAID Technology (Levels, Failure/Recovery)
        9.1.6.  Data Storage Devices (Optical Technology)
    9.2.  **File Organization**
        9.2.1.  Records and Blocks
        9.2.2.  Fixed-Length and Variable-Length Records
        9.2.3.  Heap Files (Unordered Records)
        9.2.4.  Sequential Files (Ordered Records)
        9.2.5.  Hash Files (Static and Dynamic Hashing)
        9.2.6.  Record Modifications (Insertion, Deletion, Update)
        9.2.7.  Data Compression
    9.3.  **Index Structures**
        9.3.1.  Basic Concepts (Dense, Sparse, Multilevel, Secondary Indexes)
        9.3.2.  Tree-Structured Indexes (B-Trees, B+-Trees, ISAM)
        9.3.3.  Hash-Based Indexes
        9.3.4.  Bitmap Indexes
        9.3.5.  Multidimensional Indexes (kd-Trees, R-Trees)
        9.3.6.  Index Definition in SQL

10. **Transaction Management & Concurrency Control**
    10.1. **Transaction Concepts**
        10.1.1. What is a Transaction?
        10.1.2. ACID Properties (Atomicity, Consistency, Isolation, Durability)
        10.1.3. Transaction States
        10.1.4. Savepoints and Subtransactions
        10.1.5. Transaction Control Statements (COMMIT, ROLLBACK)
        10.1.6. SET TRANSACTION Statement (Read-Only Transactions)
    10.2. **Concurrency Control**
        10.2.1. Need for Concurrency Control (Anomalies - Dirty Reads, Non-Repeatable Reads, Phantom Reads, Write Skew)
        10.2.2. Serializability (Conflict-Serializability, View Serializability)
        10.2.3. Isolation Levels (READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SNAPSHOT ISOLATION, SERIALIZABLE)
        10.2.4. Locking Protocols
            10.2.4.1. Lock Granularity (Database, Table, Page, Row, Column)
            10.2.4.2. Shared and Exclusive Locks
            10.2.4.3. Two-Phase Locking (2PL)
            10.2.4.4. Multiple Granularity Locking
            10.2.4.5. Lock Escalation
        10.2.5. Timestamp-Based Protocols
            10.2.5.1. Timestamp Ordering Protocol
            10.2.5.2. Multiversion Timestamp Ordering
        10.2.6. Validation-Based (Optimistic) Protocols
        10.2.7. Multiversion Concurrency Control (MVCC)
    10.3. **Deadlock Management**
        10.3.1. Deadlock Detection (Waits-For Graph)
        10.3.2. Deadlock Prevention (Ordering Elements, Timestamps)
        10.3.3. Deadlock Avoidance
    10.4. **Database Recovery**
        10.4.1. Failure Classification (Transaction, System, Media Failure)
        10.4.2. Recovery Concepts (Undo/Redo Logging, Checkpointing)
        10.4.3. Recovery Techniques (Deferred Update, Immediate Update, Shadow Paging, ARIES)
        10.4.4. Backup and Restore (Logical, Physical, Incremental, Differential)
        10.4.5. Remote Backup Systems

11. **Database Security & Reliability**
    11.1. **Database Security Issues**
        11.1.1. Threats to Data (Unauthorized Access, SQL Injection, Worms, Viruses)
        11.1.2. Security Goals
        11.1.3. Access Control (Discretionary, Mandatory, Role-Based Access Control - RBAC)
        11.1.4. Encryption (Data, Password, Public Key Infrastructures)
        11.1.5. Row-Level and Column-Level Security
        11.1.6. Application Contexts
        11.1.7. Fine-Grained Auditing (FGA)
    11.2. **Database Reliability and High Availability**
        11.2.1. High Availability Technologies (Failover Cluster, Database Mirroring, AlwaysOn Availability Groups)
        11.2.2. Replication (Hot Standby, Log Shipping, Asynchronous, Synchronous)
        11.2.3. Backup Strategy (Online/Offline, Incremental/Differential)
        11.2.4. Disaster Recovery (Planning, Remote Backups)

12. **Distributed & Parallel Database Systems**
    12.1. **Distributed Database Concepts**
        12.1.1. Homogeneous and Heterogeneous Systems
        12.1.2. Distributed Data Storage (Fragmentation, Replication, Allocation)
        12.1.3. Distributed DBMS Architectures (Client-Server, Peer-to-Peer)
        12.1.4. Transparencies (Location, Replication, Fragmentation)
    12.2. **Distributed Transaction Management**
        12.2.1. Distributed Concurrency Control
        12.2.2. Distributed Deadlock Management
        12.2.3. Commit Protocols (Two-Phase Commit - 2PC, Three-Phase Commit - 3PC)
        12.2.4. Distributed Database Recovery
    12.3. **Distributed Query Processing and Optimization**
    12.4. **Parallel Databases**
        12.4.1. Parallel Architectures
        12.4.2. I/O Parallelism
        12.4.3. Interquery and Intraquery Parallelism
        12.4.4. MapReduce Framework

13. **Object-Relational Databases**
    13.1. **Weaknesses of Pure Relational Systems**
    13.2. **Introduction to Object-Relational DBMS (ORDBMS)**
    13.3. **SQL:2011 (SQL-3) Features**
        13.3.1. Row Types, User-Defined Types (UDT)
        13.3.2. Subtypes and Supertypes (Inheritance, Polymorphism)
        13.3.3. User-Defined Routines (Methods, Functions, Procedures)
        13.3.4. Reference Types and Object Identity
        13.3.5. Collection Types (Arrays, Multisets)
        13.3.6. Typed Views
    13.4. **Object-Oriented Database Concepts (Brief Overview)**
        13.4.1. Object Identity, Encapsulation, Methods
        13.4.2. Class Hierarchies
        13.4.3. Complex Objects
    13.5. **Comparison of ORDBMS and OODBMS**

14. **Advanced Topics & Modern Applications**
    14.1. **Data Warehousing and OLAP (Online Analytical Processing)**
        14.1.1. Introduction and Objectives
        14.1.2. Characteristics of Data Warehouses
        14.1.3. Data Modeling for Data Warehouses (Star Schema, Snowflake Schema)
        14.1.4. OLAP Operations (Slice, Dice, Drill-down, Roll-up, Pivot)
        14.1.5. Data Cubes (Materialized Views for Aggregation)
    14.2. **Data Mining**
        14.2.1. Introduction and Functionalities
        14.2.2. Techniques (Classification, Association Rules, Clustering)
    14.3. **XML and Semistructured Data**
        14.3.1. Structure of XML Data (Well-Formed, DTD, XML Schema)
        14.3.2. Querying XML (XPath, XQuery)
        14.3.3. Storing and Extracting XML from Databases
    14.4. **Emerging Database Technologies**
        14.4.1. Spatial and Geographic Data
        14.4.2. Temporal Databases
        14.4.3. Multimedia Databases
        14.4.4. Mobile Databases
        14.4.5. Cloud-Based Databases
        14.4.6. Big Data Integration with SQL (Apache Drill)
    14.5. **Information Integration**

15. **Database Development Methodologies**
    15.1. **System Development Lifecycle (SDLC)**
    15.2. **Database System Development Lifecycle**
    15.3. **Conceptual Database Design Methodology**
    15.4. **Logical Database Design Methodology** (for Relational Model)
    15.5. **Physical Database Design Methodology** (for Relational Databases)
    15.6. **Application Design** (Transaction Design, User Interface Design)
    15.7. **Prototyping, Implementation, Testing, Maintenance**

16. **Case Studies & Specific Implementations**
    16.1. **Oracle Database** (Architecture, SQL Extensions, PL/SQL, Tuning, Security, Distributed Features)
    16.2. **PostgreSQL** (Architecture, SQL Extensions, PL/pgSQL, Admin Tools, Performance, Replication)
    16.3. **MySQL** (Architecture, SQL Extensions, Performance, Replication, Scaling)
    16.4. **SQL Server** (Architecture, T-SQL, SSIS, SSRS, Tuning, In-Memory OLTP, Security)
    16.5. **IBM DB2** (SQL Extensions, Autonomic Features)
    16.6. **Microsoft Access** (DBMS Features)
    16.7. **SQL Azure** (Cloud Database Service)

---