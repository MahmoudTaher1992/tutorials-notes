Here is a combined Table of Contents for Relational Databases, drawing from the provided sources and structured in a tree-view format with at least three levels.

---

**Combined Table of Contents: Relational Database Systems**

**I. Introduction to Databases**
    A. Core Concepts
        1. Data and Information
        2. What is a Database?
        3. What is an Application?
    B. Database Management Systems (DBMS)
        1. Definition and Purpose
        2. Characteristics of the Database Approach
        3. Advantages and Disadvantages of DBMS
        4. DBMS Structure and Components
            a. Hardware, Software, Data, Procedure, People
            b. Data Dictionary / Relational Catalogues
            c. Functional Components
        5. Roles in the Database Environment
            a. Users and Designers
            b. Data and Database Administrators (DBA)
        6. DBMS Vendors and Products
    C. History and Evolution of Database Systems
        1. Traditional File-Based Systems
            a. Limitations (Duplication, Dependence, Incompatible Formats, Isolation)
        2. Early Database Models (Hierarchical, Network)
        3. Relational Database Model: History and Impact
        4. Object Database Model
        5. Object-Relational Database Model
        6. Modern Trends and Challenges
            a. Cloud Computing
            b. Big Data and NoSQL (Contrast with Relational)
            c. Distributed Systems
            d. Data Warehousing and Data Mining (Introduction)
    D. Database Architecture
        1. Abstraction Levels in DBMS
        2. ANSI-SPARC Three-Schema Architecture
            a. External Level (Views)
            b. Conceptual Level
            c. Internal Level
        3. Data Independence
            a. Logical Data Independence
            b. Physical Data Independence
        4. Multi-Tier Architectures
            a. Two-Tier Client-Server
            b. Three-Tier Client-Server
            c. N-Tier Architectures
        5. Cloud-Based Databases (SQL Azure, Managed Services)

**II. Relational Data Model Fundamentals**
    A. Relational Model Concepts
        1. Relations and Tables
        2. Tuples / Records / Rows
        3. Attributes / Fields / Columns
        4. Domains / Elementary Data Types
        5. Relation Schemas and Instances
        6. Properties of Relations (No Duplicate Tuples, Values vs. Variables)
    B. Codd's Rules
        1. Information Rule
        2. Guaranteed Access Rule
        3. Systematic Treatment of NULL Values
        4. Active Online Catalog
        5. Comprehensive Data Sub-Language Rule
        6. View Updating Rule
        7. High-Level Insert, Update, and Delete Rule
        8. Physical Data Independence
        9. Logical Data Independence
        10. Integrity Independence
        11. Distribution Independence
        12. Non-Subversion Rule
    C. Keys in the Relational Model
        1. Superkeys
        2. Candidate Keys
        3. Primary Keys
            a. Conventions and Tailoring
            b. Artificial Keys / Surrogate Keys
            c. System-Generated Primary Keys
        4. Foreign Keys
        5. Composite Keys
    D. Relational Integrity and Constraints
        1. Entity Integrity (Primary Key NOT NULL)
        2. Domain Integrity (Data Type, CHECK Constraints)
        3. Referential Integrity (Foreign Key Constraints)
            a. Referential Constraints and NULL values
            b. ON DELETE CASCADE / SET NULL
        4. Null Values
            a. Systematic Treatment of NULL Values
            b. Why Nulls Are Prohibited (in strict models)
            c. Use Null as a Unique Value (best practice)
            d. Null as an Ordinary Value (antipattern)
        5. Generic Integrity Constraints / Assertions
    E. Formal Relational Query Languages
        1. Relational Algebra
            a. Overview and Closure
            b. Original Operators (Union, Intersection, Difference)
            c. Unary Operations (Selection, Projection, Renaming)
            d. Binary Operations (Cartesian Product, Join (Natural, Theta, Equijoin, Division))
            e. Extended Operators (Extend, Summarize, Group, Ungroup, Order By)
            f. Relational Comparisons and Assignment
            g. Advantages and Limitations
        2. Relational Calculus
            a. Tuple Relational Calculus
            b. Domain Relational Calculus
        3. Datalog
        4. Query-By-Example (QBE)

**III. Database Design and Modeling**
    A. Design Process and Methodology
        1. Database System Development Lifecycle
        2. Database Planning
        3. System Definition and Requirements Collection & Analysis
            a. Understanding Business Rules and Objectives
            b. Fact-Finding Techniques (Interviews, Document Gathering)
            c. Data Collecting and Naming
            d. Identifying Entities and Data Elements
            e. Reconciling Conflicting Requirements
        4. Design Strategies (Top-Down, Bottom-Up, Inside-Out, Mixed)
        5. Quality of a Conceptual Schema
        6. CASE Tools for Database Design
    B. Conceptual Design: Entity-Relationship (E-R) Model
        1. Introduction to E-R Modeling
        2. Building Blocks of an E-R Diagram
            a. Entity Types and Entity Sets
            b. Attributes (Simple, Composite, Multivalued, Derived)
            c. Relationship Types and Relationship Sets
        3. E-R Diagram Representation
            a. Symbols and Notations (e.g., Crow's Foot)
            b. Relationship Degree (Unary, Binary, Ternary, Quaternary)
            c. Structural Constraints (Cardinality Ratios: One-to-One, One-to-Many, Many-to-Many)
            d. Participation Constraints (Total, Partial)
            e. Attributes on Relationships
        4. Entity Set Classification (Strong Entity, Weak Entity)
        5. Problems with E-R Models (Fan Traps, Chasm Traps)
        6. Documentation of E-R Schemas
    C. Advanced Conceptual Design: Enhanced Entity-Relationship (EER) Model
        1. Specialization and Generalization
            a. Superclasses and Subclasses
            b. Attribute Inheritance (ISA Relationship)
            c. Multiple Inheritance
        2. Constraints on Specialization/Generalization (Overlap, Disjoint, Total, Partial)
        3. Aggregation and Composition
        4. Entity Clusters
        5. UML Class Diagrams for Database Design
    D. Logical Design
        1. Performance Analysis on E-R Schemas
        2. Restructuring of E-R Schemas
        3. Translation to the Relational Model
            a. Mapping Algorithm
            b. Mapping Entities, Attributes, Relationships (Binary, Ternary, Unary)
            c. Handling Composite and Multivalued Attributes
            d. Converting Weak Entities
            e. Mapping Associative Entities
            f. Mapping Subtypes and Supertypes
    E. Normalization
        1. Purpose of Normalization
        2. Redundancy and Data Anomalies (Insertion, Deletion, Update Anomalies)
        3. Functional Dependencies
            a. Definition and Characteristics
            b. Inference Rules (Armstrong's Axioms)
            c. Closure of Attributes and Functional Dependencies
            d. Minimal Cover
        4. Normal Forms Based on Functional Dependencies
            a. First Normal Form (1NF)
            b. Second Normal Form (2NF)
            c. Third Normal Form (3NF)
            d. Boyce-Codd Normal Form (BCNF)
        5. Multivalued Dependencies and Normal Forms
            a. Fourth Normal Form (4NF)
            b. Join Dependencies and Fifth Normal Form (5NF)
            c. Domain Key Normal Form (DKNF)
        6. Decomposition Properties (Lossless Join, Dependency Preservation)
        7. Database Design and Normalization (Verification on Entities/Relationships)
    F. Denormalization
        1. Why and When to Denormalize
        2. Basic Types of Denormalization
        3. Denormalization Tricks (Storing Derivable Values, Pre-Joining Tables, Hard-Coded Values, Keeping Details with Master, Short-Circuit Keys)
        4. Table Denormalization Algorithms
    G. Data Warehousing Design (Dimensional Modeling)
        1. Origin and Concepts of Data Warehouses
        2. Relational Model in Data Warehouses (Surrogate Keys, Referential Integrity)
        3. Dimensional Models (Star Schema, Snowflake Schema)
        4. Fact Tables (Measurements, Additive/Semi-Additive/Non-Additive Facts)
        5. Dimension Tables (Descriptive Context, Slowly Changing Dimensions (SCDs: Type 0-7))
        6. How to Build a Data Warehouse Model
    H. Design Principles and Antipatterns
        1. Naming Conventions (Identifiers, Clarity vs. Length)
        2. Data Cleaning and Subdividing Data Elements
        3. Planning for Changes and Scalability
        4. Avoiding ENUM and SET types
        5. Logical Design Antipatterns (Jaywalking, Naive Trees, Keyless Entry, Entity-Attribute-Value, Polymorphic Associations, Multicolumn Attributes, Metadata Tribbles)
        6. Physical Design Antipatterns (Rounding Errors, 31 Flavors, Phantom Files, Index Shotgun)

**IV. SQL Language**
    A. SQL Fundamentals
        1. What Is SQL? (Definition, History, ANSI Standards)
        2. Significance of SQL (Standardized Relational Language)
        3. SQL Terms (Keywords, Functions, Identifiers, Aliases, Statements, Clauses, Expressions, Predicates)
        4. Lexical Structure (Comments, Quotes, Whitespace)
        5. Sublanguages (DDL, DML, DCL, TCL)
        6. SQL Dialects (Microsoft SQL Server, MySQL, Oracle, PostgreSQL, DB2)
    B. Data Definition Language (DDL)
        1. Creating a Database
        2. Creating Tables (CREATE TABLE)
            a. Specifying Columns and Data Types
            b. Specifying Table Constraints (NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK)
            c. Default Domain Values
        3. Altering Tables (ALTER TABLE)
            a. Adding/Modifying/Deleting Columns
            b. Renaming Tables
        4. Deleting Tables (DROP TABLE, TRUNCATE TABLE)
        5. Creating Schemas
        6. Creating User-Defined Types (UDT) / Domains
        7. Creating Indexes (CREATE INDEX)
    C. Data Manipulation Language (DML)
        1. Inserting Data (INSERT Statement)
            a. Adding a New Row / Multiple Rows
            b. Inserting Default Values
            c. Inserting Data from an Existing Table (INSERT...SELECT)
        2. Updating Data (UPDATE Statement)
            a. Modifying Existing Rows
            b. Updating with Values from Another Table
            c. Correlated Subquery Updates
        3. Deleting Data (DELETE Statement)
            a. Deleting Specific Records
            b. Deleting All Records from a Table
        4. Merging Records (MERGE Statement)
        5. SELECT INTO Statement
    D. Querying Data: The SELECT Statement
        1. Basic SELECT Syntax
        2. Selecting All Rows and Columns
        3. Querying a Subset of Columns
        4. Column Aliases and Table Aliases
        5. Removing Duplicate Rows (DISTINCT, UNION DISTINCT)
    E. Filtering, Sorting, and Grouping Data
        1. The WHERE Clause
            a. Search Conditions and Operators (Comparison, BETWEEN, IN, LIKE, SIMILAR, NULL)
            b. Boolean Logic (AND, OR, NOT, Parentheses)
            c. Filtering on Subqueries
            d. Predicates (EXISTS, UNIQUE, OVERLAPS, MATCH)
        2. The ORDER BY Clause (Sorting in Ascending/Descending Order, by Multiple Columns, by Calculated Field)
        3. The GROUP BY Clause
            a. Grouping Data (Single-Column, Multicolumn, by Expressions)
            b. Group Filter Conditions (HAVING Clause)
        4. Limiting Results (LIMIT, OFFSET, TOP N)
        5. Conditional Logic (CASE Expressions - Simple, Searched, NULLIF, COALESCE)
    F. Joins
        1. Cartesian Product (CROSS JOIN)
        2. Inner Joins (EQUIJOIN, NATURAL JOIN, JOIN ON Condition)
        3. Outer Joins (LEFT, RIGHT, FULL OUTER JOIN)
        4. Self-Joins
        5. Join Conditions vs. Filter Conditions
        6. Optimizing Joins
    G. Subqueries and Common Table Expressions (CTEs)
        1. What is a Subquery?
        2. Noncorrelated Subqueries (Returning Single/Multiple Values, Multicolumn Subqueries)
        3. Correlated Subqueries (Existence Test with EXISTS)
        4. Nested Subqueries
        5. Subqueries in FROM, WHERE, HAVING, SELECT Clauses
        6. DML Actions Using Subqueries (INSERT, UPDATE, DELETE)
        7. Common Table Expressions (WITH Clause)
            a. Reusing SQL Code
            b. Recursive CTEs for Hierarchical Queries
    H. Set Operations
        1. UNION (UNION ALL for non-distinct)
        2. INTERSECT
        3. EXCEPT / MINUS
        4. Set Operation Rules and Precedence
    I. Functions and Expressions
        1. String Functions (CONCAT, SUBSTR, LENGTH, LPAD, RPAD, TRIM, REPLACE, INSERT, REGEXP)
        2. Numeric Functions (ROUND, TRUNC, MOD, ABS, POWER, AVG, COUNT, MAX, MIN, SUM)
        3. Date/Time Functions (NOW, CURDATE, CURTIME, DATE_ADD, DATE_SUB, DATEDIFF, DATE_FORMAT, EXTRACT)
        4. Conversion Functions (CAST, TO_CHAR, TO_NUMBER, TO_DATE)
        5. Aggregate Functions (COUNT, SUM, AVG, MAX, MIN)
        6. Statistical Group Functions (STDDEV, VARIANCE)
        7. Regular Expressions
        8. Value Expressions (Numeric, String, Datetime, Interval, Boolean)
    J. Views and Materialized Views
        1. What Are Views?
        2. Creating Views (Simple Views, Complex Views, WITH CHECK OPTION)
        3. Benefits of Views (Data Security, Data Aggregation, Hiding Complexity)
        4. Updatable Views (Simple, Complex, INSTEAD OF Triggers)
        5. Dropping Views
        6. Inline Views
        7. Materialized Views
            a. Purpose and Creation
            b. Refresh Strategies
            c. Rewriting Queries to Use Materialized Views
    K. Integrity Constraints in SQL
        1. Declaring Constraints at Column and Table Levels
        2. NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK Constraints
        3. Assertions
        4. Modifying and Dropping Constraints
    L. Advanced Querying Techniques
        1. Window Functions (Analytic Functions)
            a. Partitioning and Ordering (PARTITION BY, ORDER BY)
            b. Ranking Functions (RANK, DENSE_RANK, NTILE, ROW_NUMBER)
            c. Value Functions (LAG, LEAD, FIRST_VALUE, LAST_VALUE)
            d. Aggregate Functions with Window Frames (Moving Average, Running Total)
        2. Subtotals and Crosstabs (ROLLUP, CUBE, GROUPING SETS)
        3. Pivoting and Unpivoting Data (Cross Tabulations)
        4. Hierarchical Queries (Parent-Child, CONNECT BY, Recursive CTEs)
        5. Full-Text Search
        6. Regular Expressions for Pattern Matching and Data Extraction
    M. XML and JSON Support in SQL
        1. XML Data Type and Data Model
        2. SQL/XML Functions (XMLELEMENT, XMLFOREST, XMLAGG, XMLPARSE, XMLQUERY, XMLCAST)
        3. SQL/XML Predicates (XMLEXISTS, XMLVALID)
        4. Storing and Retrieving XML Data (OPENXML, SELECT FOR XML)
        5. JSON Data Type and Data Model
        6. SQL/JSON Functions (JSON_VALUE, JSON_QUERY, JSON_OBJECT, JSON_ARRAY)
        7. Storing and Querying JSON Data

**V. Database Objects and Programmability**
    A. Indexes
        1. What Is an Index?
        2. Types of Indexes
            a. B-Tree Indexes (Primary, Unique, Standard)
            b. Clustered Indexes vs. Heap Tables
            c. Nonclustered Indexes
            d. Composite Indexes / Multicolumn Indexes
            e. Covering Indexes
            f. Filtered Indexes / Partial Indexes
            g. Hash Indexes
            h. Bitmap Indexes
            i. Function-Based Indexes
            j. Full-Text Indexes
            k. Spatial Indexes
            l. Memory-Optimized Indexes
            m. Columnstore Indexes
            n. GIN and GiST Indexes
        3. How Indexes Are Used (Index Scans, Seeks, Index Lookups)
        4. Benefits and Downside of Indexes
        5. Index Maintenance (Rebuilding, Fragmentation, Unused Indexes)
    B. Stored Procedures and Functions
        1. SQL-Invoked Routines
        2. Creating Stored Procedures (PROCEDURE)
            a. Input/Output Parameters
            b. Modifying Data with Procedures
        3. Creating User-Defined Functions (FUNCTION)
            a. Scalar Functions
            b. Table-Valued Functions (Inline, Multi-Statement)
            c. Calling Functions from SQL
        4. PL/SQL and T-SQL Programming
            a. Block Structure and Language Elements
            b. Control Statements (Conditional, Iterative, Sequential)
            c. Variables and Data Types
            d. Exception Handling
            e. Dynamic SQL (EXECUTE IMMEDIATE, OPEN FOR)
            f. Cursors (Implicit, Explicit, REF CURSORs)
            g. Packages (Oracle PL/SQL)
            h. Autonomous Transactions
        5. Debugging Stored Code
    C. Triggers
        1. What Is a Trigger?
        2. Types of Triggers (DML, DDL, Logon, Database Events)
        3. Creating Triggers (BEFORE/AFTER, FOR EACH ROW, WHEN Clause)
        4. Trigger Execution Context (Old/New Values, Mutating Table Errors)
        5. INSTEAD OF Triggers (for Views)
        6. Compound Triggers
        7. Applications of Triggers (Auditing, Enforcing Constraints, Event Logging)
        8. Managing and Maintaining Triggers
    D. Cursors
        1. What Is a Cursor? (Implicit, Explicit)
        2. Declaring, Opening, Fetching, and Closing Cursors
        3. Cursor Attributes (%FOUND, %ISOPEN, %NOTFOUND, %ROWCOUNT)
        4. Fetching Data (Single Row, Multiple Rows with BULK COLLECT)
        5. Positioned UPDATE and DELETE Statements
        6. Cursor Variables (REF CURSORs)
    E. Packages (PL/SQL Specific)
        1. What is a PL/SQL Package?
        2. Package Specification and Body
        3. Advantages of Packages (Encapsulation, Reusability, Global Data, Performance)
        4. Private and Public Items
        5. Standard Packages (DBMS_OUTPUT, UTL_FILE, UTL_HTTP)
    F. User-Defined Types (UDT)
        1. Creating Custom Data Types
        2. Composite Data Types
    G. Other Database Objects
        1. Sequences (Creating, Using, Altering, Removing)
        2. Synonyms

**VI. Transaction Management and Concurrency Control**
    A. Transaction Concepts
        1. What Is a Transaction?
        2. Transaction States
        3. Logical Operations of Transactions
        4. Transaction Support in SQL
    B. ACID Properties
        1. Atomicity
        2. Consistency
        3. Isolation
        4. Durability
    C. Concurrency Control
        1. Need for Concurrency Control (Anomalies of Concurrent Transactions)
        2. Serializability (Conflict-Serializability, View Serializability)
        3. Recoverability