Contents
Preface............................................................................................................................................................. xxxi
Audience................................................................................................................................................... xxxi
Documentation Accessibility................................................................................................................. xxxi
Related Documents ................................................................................................................................ xxxii
Conventions ............................................................................................................................................ xxxii
Syntax Descriptions............................................................................................................................... xxxiii
What's New in PL/SQL?....................................................................................................................... xxxv
xxxv
1-3
1-4
1-6
1-7
New PL/SQL Features for 11g Release 1 (11.1) ................................................................................ 1 Overview of PL/SQL
Advantages of PL/SQL............................................................................................................................ 1-1
Tight Integration with SQL............................................................................................................... 1-1
High Performance .............................................................................................................................. 1-2
High Productivity .............................................................................................................................. 1-2
Full Portability.................................................................................................................................... 1-3
Tight Security...................................................................................................................................... 1-3
Access to Predefined Packages......................................................................................................... 1-3
Support for Object-Oriented Programming ................................................................................... Support for Developing Web Applications and Server Pages .................................................... Main Features of PL/SQL........................................................................................................................ 1-4
PL/SQL Blocks ................................................................................................................................... 1-4
PL/SQL Error Handling ................................................................................................................... 1-5
PL/SQL Input and Output ............................................................................................................... PL/SQL Variables and Constants.................................................................................................... 1-6
Declaring PL/SQL Variables..................................................................................................... 1-6
Assigning Values to Variables .................................................................................................. Declaring PL/SQL Constants.................................................................................................... 1-9
Bind Variables ............................................................................................................................. 1-9
PL/SQL Data Abstraction................................................................................................................. 1-9
Cursors ...................................................................................................................................... 1-10
%TYPE Attribute...................................................................................................................... 1-10
%ROWTYPE Attribute ............................................................................................................ 1-10
Collections................................................................................................................................. 1-11
Records ...................................................................................................................................... 1-12
v
Object Types ............................................................................................................................. 1-12
PL/SQL Control Structures ........................................................................................................... 1-13
Conditional Control................................................................................................................. 1-13
Iterative Control ....................................................................................................................... 1-15
Sequential Control ................................................................................................................... 1-17
PL/SQL Subprograms.................................................................................................................... 1-17
Standalone PL/SQL Subprograms........................................................................................ 1-18
Triggers...................................................................................................................................... 1-19
PL/SQL Packages (APIs Written in PL/SQL) ............................................................................ 1-20
Conditional Compilation ............................................................................................................... 1-23
Embedded SQL Statements ........................................................................................................... 1-23
Architecture of PL/SQL........................................................................................................................ 1-24
PL/SQL Engine ............................................................................................................................... 1-24
PL/SQL Units and Compilation Parameters .............................................................................. 1-25
2 PL/SQL Language Fundamentals
Character Sets and Lexical Units........................................................................................................... 2-1
Delimiters ............................................................................................................................................ 2-3
Identifiers ............................................................................................................................................ 2-4
Reserved Words and Keywords ............................................................................................... 2-5
Predefined Identifiers................................................................................................................. 2-5
Quoted Identifiers....................................................................................................................... 2-5
Literals ................................................................................................................................................. 2-6
Numeric Literals.......................................................................................................................... 2-6
Character Literals........................................................................................................................ 2-7
String Literals............................................................................................................................... 2-7
BOOLEAN Literals ..................................................................................................................... 2-8
Date and Time Literals ............................................................................................................... 2-8
Comments ........................................................................................................................................... 2-9
Single-Line Comments ............................................................................................................... 2-9
Multiline Comments................................................................................................................ 2-10
Declarations............................................................................................................................................ 2-10
Variables ........................................................................................................................................... 2-11
Constants .......................................................................................................................................... 2-11
Using DEFAULT ............................................................................................................................. 2-11
Using NOT NULL........................................................................................................................... 2-12
Using the %TYPE Attribute........................................................................................................... 2-12
Using the %ROWTYPE Attribute ................................................................................................. 2-15
Aggregate Assignment............................................................................................................ 2-16
Using Aliases ............................................................................................................................ 2-17
Restrictions on Declarations .......................................................................................................... 2-18
Naming Conventions............................................................................................................................ 2-19
Scope ................................................................................................................................................. 2-19
Case Sensitivity................................................................................................................................ 2-20
Name Resolution............................................................................................................................. 2-20
Synonyms ......................................................................................................................................... 2-22
Scope and Visibility of PL/SQL Identifiers..................................................................................... 2-22
vi
Assigning Values to Variables............................................................................................................ 2-26
Assigning BOOLEAN Values........................................................................................................ 2-27
Assigning SQL Query Results to PL/SQL Variables................................................................. 2-27
PL/SQL Expressions and Comparisons............................................................................................. 2-28
Concatenation Operator................................................................................................................. 2-28
Operator Precedence....................................................................................................................... 2-28
Logical Operators............................................................................................................................ 2-30
Order of Evaluation ................................................................................................................. 2-33
Short-Circuit Evaluation ......................................................................................................... 2-34
Comparison Operators............................................................................................................ 2-34
IS NULL Operator ............................................................................................................ 2-35
LIKE Operator ................................................................................................................... 2-35
BETWEEN Operator......................................................................................................... 2-37
IN Operator ....................................................................................................................... 2-37
BOOLEAN Expressions ................................................................................................................. 2-38
BOOLEAN Arithmetic Expressions ...................................................................................... 2-38
BOOLEAN Character Expressions........................................................................................ 2-39
BOOLEAN Date Expressions................................................................................................. 2-39
Guidelines for BOOLEAN Expressions................................................................................ 2-40
CASE Expressions........................................................................................................................... 2-40
Simple CASE Expression ........................................................................................................ 2-41
Searched CASE Expression .................................................................................................... 2-41
Handling NULL Values in Comparisons and Conditional Statements.................................. 2-42
NULL Values and the NOT Operator................................................................................... 2-43
NULL Values and Zero-Length Strings................................................................................ 2-44
NULL Values and the Concatenation Operator.................................................................. 2-44
NULL Values as Arguments to Built-In Functions............................................................. 2-45
PL/SQL Error-Reporting Functions.................................................................................................... 2-47
Using SQL Functions in PL/SQL........................................................................................................ 2-47
Conditional Compilation..................................................................................................................... 2-48
How Does Conditional Compilation Work?............................................................................... 2-48
Conditional Compilation Control Tokens............................................................................ 2-48
Using Conditional Compilation Selection Directives......................................................... 2-49
Using Conditional Compilation Error Directives ............................................................... 2-49
Using Conditional Compilation Inquiry Directives ........................................................... 2-49
Using Predefined Inquiry Directives with Conditional Compilation.............................. 2-50
Using Static Expressions with Conditional Compilation................................................... 2-50
Boolean Static Expressions .............................................................................................. 2-51
PLS_INTEGER Static Expressions.................................................................................. 2-51
VARCHAR2 Static Expressions...................................................................................... 2-51
Static Constants................................................................................................................. 2-52
Using DBMS_DB_VERSION Package Constants................................................................ 2-53
Conditional Compilation Examples ............................................................................................. 2-54
Using Conditional Compilation to Specify Code for Database Versions ........................ 2-54
Using DBMS_PREPROCESSOR Procedures to Print or Retrieve Source Text ............... 2-55
Conditional Compilation Restrictions.......................................................................................... 2-55
Using PL/SQL to Create Web Applications...................................................................................... 2-56
vii
Using PL/SQL to Create Server Pages............................................................................................... 2-57
3 PL/SQL Data Types
Predefined PL/SQL Scalar Data Types and Subtypes....................................................................... 3-1
Predefined PL/SQL Numeric Data Types and Subtypes ............................................................ 3-2
PLS_INTEGER and BINARY_INTEGER Data Types............................................................ 3-2
SIMPLE_INTEGER Subtype of PLS_INTEGER ..................................................................... 3-3
Overflow Semantics............................................................................................................. 3-3
Overloading Rules............................................................................................................... 3-4
Integer Literals ..................................................................................................................... 3-4
Cast Operations.................................................................................................................... 3-5
Compiler Warnings ............................................................................................................. 3-5
BINARY_FLOAT and BINARY_DOUBLE Data Types ........................................................ 3-5
NUMBER Data Type .................................................................................................................. 3-6
Predefined PL/SQL Character Data Types and Subtypes........................................................... 3-7
CHAR and VARCHAR2 Data Types ...................................................................................... 3-8
Predefined Subtypes of Character Data Types................................................................ 3-9
Memory Allocation for Character Variables.................................................................... 3-9
Blank-Padding Shorter Character Values ..................................................................... 3-10
Comparing Character Values.......................................................................................... 3-10
Maximum Sizes of Values Inserted into Character Database Columns ................... 3-11
RAW Data Type ....................................................................................................................... 3-12
NCHAR and NVARCHAR2 Data Types ............................................................................. 3-12
AL16UTF16 and UTF8 Encodings.................................................................................. 3-12
NCHAR Data Type........................................................................................................... 3-13
NVARCHAR2 Data Type................................................................................................ 3-14
LONG and LONG RAW Data Types.................................................................................... 3-14
ROWID and UROWID Data Types....................................................................................... 3-14
Predefined PL/SQL BOOLEAN Data Type................................................................................ 3-15
Predefined PL/SQL Datetime and Interval Data Types ........................................................... 3-15
DATE Data Type...................................................................................................................... 3-16
TIMESTAMP Data Type ......................................................................................................... 3-17
TIMESTAMP WITH TIME ZONE Data Type ..................................................................... 3-18
TIMESTAMP WITH LOCAL TIME ZONE Data Type ...................................................... 3-19
INTERVAL YEAR TO MONTH Data Type......................................................................... 3-20
INTERVAL DAY TO SECOND Data Type.......................................................................... 3-20
Datetime and Interval Arithmetic ......................................................................................... 3-21
Avoiding Truncation Problems Using Date and Time Subtypes ..................................... 3-21
Predefined PL/SQL Large Object (LOB) Data Types..................................................................... 3-22
BFILE Data Type ............................................................................................................................. 3-23
BLOB Data Type.............................................................................................................................. 3-23
CLOB Data Type ............................................................................................................................. 3-23
NCLOB Data Type .......................................................................................................................... 3-23
User-Defined PL/SQL Subtypes......................................................................................................... 3-23
Defining Subtypes .......................................................................................................................... 3-24
Using Subtypes................................................................................................................................ 3-24
Type Compatibility with Subtypes ....................................................................................... 3-25
viii
4 5 Constraints and Default Values with Subtypes................................................................... 3-26
PL/SQL Data Type Conversion........................................................................................................... 3-28
Explicit Conversion......................................................................................................................... 3-28
Implicit Conversion ........................................................................................................................ 3-29
Using PL/SQL Control Structures
Overview of PL/SQL Control Structures............................................................................................. 4-1
Testing Conditions (IF and CASE Statements)................................................................................... 4-2
Using the IF-THEN Statement ......................................................................................................... 4-2
Using the IF-THEN-ELSE Statement............................................................................................... 4-2
Using the IF-THEN-ELSIF Statement.............................................................................................. 4-4
Using the Simple CASE Statement .................................................................................................. 4-5
Using the Searched CASE Statement .............................................................................................. 4-6
Guidelines for IF and CASE Statements ......................................................................................... 4-7
Controlling Loop Iterations (LOOP, EXIT, and CONTINUE Statements).................................... 4-8
Using the Basic LOOP Statement..................................................................................................... 4-9
Using the EXIT Statement ................................................................................................................. 4-9
Using the EXIT-WHEN Statement................................................................................................ 4-10
Using the CONTINUE Statement................................................................................................. 4-10
Using the CONTINUE-WHEN Statement .................................................................................. 4-11
Labeling a PL/SQL Loop ............................................................................................................... 4-12
Using the WHILE-LOOP Statement............................................................................................. 4-13
Using the FOR-LOOP Statement .................................................................................................. 4-13
How PL/SQL Loops Repeat................................................................................................... 4-15
Dynamic Ranges for Loop Bounds........................................................................................ 4-16
Scope of the Loop Counter Variable ..................................................................................... 4-17
Using the EXIT Statement in a FOR Loop ............................................................................ 4-19
Sequential Control (GOTO and NULL Statements)...................................................................... 4-20
Using the GOTO Statement ........................................................................................................... 4-20
GOTO Statement Restrictions ....................................................................................................... 4-22
Using the NULL Statement............................................................................................................ 4-23
Using PL/SQL Collections and Records
Understanding PL/SQL Collection Types........................................................................................... 5-1
Understanding Associative Arrays (Index-By Tables) ................................................................. 5-2
Understanding Nested Tables.......................................................................................................... 5-4
Understanding Variable-Size Arrays (Varrays)............................................................................. 5-5
Choosing PL/SQL Collection Types..................................................................................................... 5-5
Choosing Between Nested Tables and Associative Arrays ......................................................... 5-5
Choosing Between Nested Tables and Varrays............................................................................. 5-6
Defining Collection Types...................................................................................................................... 5-6
Declaring Collection Variables.............................................................................................................. 5-8
Initializing and Referencing Collections......................................................................................... 5-10
Referencing Collection Elements....................................................................................................... 5-12
Assigning Values to Collections......................................................................................................... 5-13
Comparing Collections......................................................................................................................... 5-17
ix
Using Multidimensional Collections................................................................................................ 5-19
Using Collection Methods................................................................................................................... 5-20
Checking If a Collection Element Exists (EXISTS Method) ...................................................... 5-21
Counting the Elements in a Collection (COUNT Method) ....................................................... 5-21
Checking the Maximum Size of a Collection (LIMIT Method) ................................................ 5-22
Finding the First or Last Collection Element (FIRST and LAST Methods) ............................ 5-22
Looping Through Collection Elements (PRIOR and NEXT Methods).................................... 5-23
Increasing the Size of a Collection (EXTEND Method) ............................................................. 5-24
Decreasing the Size of a Collection (TRIM Method).................................................................. 5-26
Deleting Collection Elements (DELETE Method) ...................................................................... 5-27
Applying Methods to Collection Parameters.............................................................................. 5-28
Avoiding Collection Exceptions......................................................................................................... 5-28
Defining and Declaring Records........................................................................................................ 5-31
Using Records as Subprogram Parameters and Function Return Values.................................. 5-33
Assigning Values to Records............................................................................................................... 5-34
Comparing Records ........................................................................................................................ 5-36
Inserting Records Into the Database............................................................................................. 5-36
Updating the Database with Record Values ............................................................................... 5-36
Restrictions on Record Inserts and Updates ............................................................................... 5-38
Querying Data Into Collections of Records................................................................................. 5-38
6 Using Static SQL
Description of Static SQL....................................................................................................................... 6-1
Data Manipulation Language (DML) Statements ......................................................................... 6-1
Transaction Control Language (TCL) Statements......................................................................... 6-3
SQL Functions..................................................................................................................................... 6-3
SQL Pseudocolumns.......................................................................................................................... 6-4
CURRVAL and NEXTVAL........................................................................................................ 6-4
LEVEL........................................................................................................................................... 6-5
ROWID ......................................................................................................................................... 6-5
ROWNUM ................................................................................................................................... 6-6
SQL Operators .................................................................................................................................... 6-6
Comparison Operators............................................................................................................... 6-6
Set Operators ............................................................................................................................... 6-7
Row Operators ............................................................................................................................ 6-7
Managing Cursors in PL/SQL................................................................................................................ 6-7
SQL Cursors (Implicit) ...................................................................................................................... 6-7
Attributes of SQL Cursors ......................................................................................................... 6-8
%FOUND Attribute: Has a DML Statement Changed Rows?...................................... 6-8
%ISOPEN Attribute: Always FALSE for SQL Cursors .................................................. 6-8
%NOTFOUND Attribute: Has a DML Statement Failed to Change Rows? ............... 6-8
%ROWCOUNT Attribute: How Many Rows Affected So Far?.................................... 6-8
Guidelines for Using Attributes of SQL Cursors ................................................................... 6-9
Explicit Cursors .................................................................................................................................. 6-9
Declaring a Cursor................................................................................................................... 6-10
Opening a Cursor..................................................................................................................... 6-11
Fetching with a Cursor............................................................................................................ 6-11
x
Fetching Bulk Data with a Cursor ......................................................................................... 6-12
Closing a Cursor....................................................................................................................... 6-13
Attributes of Explicit Cursors ................................................................................................ 6-13
%FOUND Attribute: Has a Row Been Fetched? .......................................................... 6-13
%ISOPEN Attribute: Is the Cursor Open? .................................................................... 6-14
%NOTFOUND Attribute: Has a Fetch Failed?............................................................. 6-14
%ROWCOUNT Attribute: How Many Rows Fetched So Far? .................................. 6-15
Querying Data with PL/SQL............................................................................................................... 6-16
Selecting At Most One Row (SELECT INTO Statement) .......................................................... 6-16
Selecting Multiple Rows (BULK COLLECT Clause) ................................................................. 6-17
Looping Through Multiple Rows (Cursor FOR Loop).............................................................. 6-17
Performing Complicated Query Processing (Explicit Cursors) ............................................... 6-17
Cursor FOR LOOP .......................................................................................................................... 6-18
SQL Cursor FOR LOOP .......................................................................................................... 6-18
Explicit Cursor FOR LOOP..................................................................................................... 6-18
Defining Aliases for Expression Values in a Cursor FOR Loop............................................... 6-19
Using Subqueries.................................................................................................................................. 6-19
Using Correlated Subqueries......................................................................................................... 6-20
Writing Maintainable PL/SQL Subqueries................................................................................. 6-21
Using Cursor Variables (REF CURSORs)......................................................................................... 6-22
What Are Cursor Variables (REF CURSORs)?............................................................................ 6-23
Why Use Cursor Variables?........................................................................................................... 6-23
Declaring REF CURSOR Types and Cursor Variables .............................................................. 6-23
Passing Cursor Variables As Parameters .................................................................................... 6-24
Controlling Cursor Variables (OPEN-FOR, FETCH, and CLOSE Statements)...................... 6-25
Opening a Cursor Variable..................................................................................................... 6-25
Using a Cursor Variable as a Host Variable......................................................................... 6-27
Fetching from a Cursor Variable ........................................................................................... 6-28
Closing a Cursor Variable....................................................................................................... 6-29
Reducing Network Traffic When Passing Host Cursor Variables to PL/SQL ...................... 6-29
Avoiding Errors with Cursor Variables....................................................................................... 6-30
Restrictions on Cursor Variables .................................................................................................. 6-30
Using Cursor Expressions.................................................................................................................... 6-31
Overview of Transaction Processing in PL/SQL............................................................................. 6-32
Using COMMIT in PL/SQL .......................................................................................................... 6-33
Using ROLLBACK in PL/SQL...................................................................................................... 6-34
Using SAVEPOINT in PL/SQL .................................................................................................... 6-35
How the Database Does Implicit Rollbacks ................................................................................ 6-36
Ending Transactions ....................................................................................................................... 6-36
Setting Transaction Properties (SET TRANSACTION Statement) .......................................... 6-37
Overriding Default Locking .......................................................................................................... 6-37
Using FOR UPDATE ............................................................................................................... 6-38
Using LOCK TABLE................................................................................................................ 6-39
Fetching Across Commits....................................................................................................... 6-39
Doing Independent Units of Work with Autonomous Transactions.......................................... 6-40
Advantages of Autonomous Transactions .................................................................................. 6-41
Defining Autonomous Transactions ............................................................................................ 6-41
xi
Comparison of Autonomous Transactions and Nested Transactions ............................. 6-43
Transaction Context................................................................................................................. 6-43
Transaction Visibility............................................................................................................... 6-43
Controlling Autonomous Transactions ....................................................................................... 6-44
Entering and Exiting................................................................................................................ 6-44
Committing and Rolling Back................................................................................................ 6-44
Using Savepoints...................................................................................................................... 6-44
Avoiding Errors with Autonomous Transactions............................................................... 6-45
Using Autonomous Triggers......................................................................................................... 6-45
Invoking Autonomous Functions from SQL............................................................................... 6-46
7 Using Dynamic SQL
When You Need Dynamic SQL............................................................................................................. 7-1
Using Native Dynamic SQL................................................................................................................... 7-2
Using the EXECUTE IMMEDIATE Statement............................................................................... 7-2
Using the OPEN-FOR, FETCH, and CLOSE Statements ............................................................. 7-4
Repeating Placeholder Names in Dynamic SQL Statements....................................................... 7-5
Dynamic SQL Statement is Not Anonymous Block or CALL Statement ........................... 7-5
Dynamic SQL Statement is Anonymous Block or CALL Statement ................................... 7-5
Using DBMS_SQL Package................................................................................................................... 7-6
DBMS_SQL.TO_REFCURSOR Function ........................................................................................ 7-7
DBMS_SQL.TO_CURSOR_NUMBER Function............................................................................ 7-8
Avoiding SQL Injection in PL/SQL...................................................................................................... 7-9
Overview of SQL Injection Techniques .......................................................................................... 7-9
Statement Modification.............................................................................................................. 7-9
Statement Injection .................................................................................................................. 7-11
Data Type Conversion............................................................................................................. 7-12
Guarding Against SQL Injection................................................................................................... 7-14
Using Bind Arguments to Guard Against SQL Injection................................................... 7-14
Using Validation Checks to Guard Against SQL Injection................................................ 7-15
Using Explicit Format Models to Guard Against SQL Injection....................................... 7-17
8 Using PL/SQL Subprograms
Overview of PL/SQL Subprograms...................................................................................................... 8-1
Subprogram Parts..................................................................................................................................... 8-3
Creating Nested Subprograms that Invoke Each Other................................................................... 8-5
Declaring and Passing Subprogram Parameters................................................................................ 8-6
Formal and Actual Subprogram Parameters ................................................................................. 8-6
Specifying Subprogram Parameter Modes..................................................................................... 8-7
Using IN Mode............................................................................................................................ 8-8
Using OUT Mode........................................................................................................................ 8-8
Using IN OUT Mode .................................................................................................................. 8-9
Summary of Subprogram Parameter Modes .......................................................................... 8-9
Specifying Default Values for Subprogram Parameters .............................................................. 8-9
Passing Actual Subprogram Parameters with Positional, Named, or Mixed Notation ....... 8-11
Overloading PL/SQL Subprogram Names....................................................................................... 8-12
Guidelines for Overloading with Numeric Types ..................................................................... 8-13
xii
Restrictions on Overloading.......................................................................................................... 8-14
When Compiler Catches Overloading Errors............................................................................. 8-14
How PL/SQL Subprogram Calls Are Resolved............................................................................... 8-16
Using Invoker's Rights or Definer's Rights (AUTHID Clause)................................................... 8-18
Choosing Between AUTHID CURRENT_USER and AUTHID DEFINER............................. 8-19
AUTHID and the SQL Command SET ROLE............................................................................. 8-20
Need for Template Objects in IR Subprograms.......................................................................... 8-20
Overriding Default Name Resolution in IR Subprograms ....................................................... 8-20
Using Views and Database Triggers with IR Subprograms ..................................................... 8-20
Using Database Links with IR Subprograms.............................................................................. 8-20
Using Object Types with IR Subprograms .................................................................................. 8-21
Invoking IR Instance Methods ...................................................................................................... 8-22
Using Recursive PL/SQL Subprograms............................................................................................ 8-23
Invoking External Subprograms........................................................................................................ 8-23
Controlling Side Effects of PL/SQL Subprograms......................................................................... 8-24
Understanding PL/SQL Subprogram Parameter Aliasing............................................................ 8-25
Using the PL/SQL Function Result Cache........................................................................................ 8-27
Enabling Result-Caching for a Function...................................................................................... 8-28
Developing Applications with Result-Cached Functions......................................................... 8-29
Restrictions on Result-Cached Functions .................................................................................... 8-29
Examples of Result-Cached Functions......................................................................................... 8-30
Result-Cached Application Configuration Parameters...................................................... 8-30
Result-Cached Recursive Function........................................................................................ 8-32
Advanced Result-Cached Function Topics ................................................................................. 8-32
Rules for a Cache Hit............................................................................................................... 8-32
Bypassing the Result Cache.................................................................................................... 8-33
Making Result-Cached Functions Handle Session-Specific Settings ............................... 8-33
Making Result-Cached Functions Handle Session-Specific Application Contexts........ 8-34
Choosing Result-Caching Granularity.................................................................................. 8-35
Result Caches in Oracle RAC Environment......................................................................... 8-36
Managing the Result Cache.................................................................................................... 8-37
Hot-Patching PL/SQL Units on Which Result-Cached Functions Depend.................... 8-37
9 Using Triggers
Overview of Triggers............................................................................................................................... 9-1
Trigger Types...................................................................................................................................... 9-2
Trigger States ...................................................................................................................................... 9-2
Data Access for Triggers ................................................................................................................... 9-2
Uses of Triggers.................................................................................................................................. 9-3
Guidelines for Designing Triggers....................................................................................................... 9-3
Privileges Required to Use Triggers..................................................................................................... 9-4
Creating Triggers ..................................................................................................................................... 9-5
Naming Triggers ............................................................................................................................... 9-6
When Does the Trigger Fire? ........................................................................................................... 9-6
Do Import and SQL*Loader Fire Triggers?............................................................................. 9-6
How Column Lists Affect UPDATE Triggers ........................................................................ 9-7
Controlling When a Trigger Fires (BEFORE and AFTER Options) ........................................... 9-7
xiii
Ordering of Triggers.......................................................................................................................... 9-8
Modifying Complex Views (INSTEAD OF Triggers)................................................................... 9-8
Views that Require INSTEAD OF Triggers............................................................................. 9-9
Triggers on Nested Table View Columns ............................................................................... 9-9
Example: INSTEAD OF Trigger............................................................................................. 9-11
Firing Triggers One or Many Times (FOR EACH ROW Option) ........................................... 9-12
Firing Triggers Based on Conditions (WHEN Clause) ............................................................. 9-13
Compound Triggers........................................................................................................................ 9-13
Why Use Compound Triggers? ............................................................................................. 9-13
Compound Trigger Sections................................................................................................... 9-14
Triggering Statements of Compound Triggers.................................................................... 9-15
Compound Trigger Restrictions ............................................................................................ 9-15
Compound Trigger Example ................................................................................................. 9-16
Using Compound Triggers to Avoid Mutating-Table Error ............................................. 9-18
Coding the Trigger Body ..................................................................................................................... 9-18
Accessing Column Values in Row Triggers ............................................................................... 9-20
Example: Modifying LOB Columns with a Trigger............................................................ 9-20
INSTEAD OF Triggers on Nested Table View Columns ................................................... 9-21
Avoiding Trigger Name Conflicts (REFERENCING Option) .......................................... 9-21
Detecting the DML Operation that Fired a Trigger ............................................................ 9-22
Error Conditions and Exceptions in the Trigger Body ...................................................... 9-22
Triggers on Object Tables............................................................................................................... 9-22
Triggers and Handling Remote Exceptions ............................................................................... 9-23
Restrictions on Creating Triggers ................................................................................................ 9-24
Maximum Trigger Size............................................................................................................ 9-24
SQL Statements Allowed in Trigger Bodies......................................................................... 9-25
Trigger Restrictions on LONG and LONG RAW Data Types .......................................... 9-25
Trigger Restrictions on Mutating Tables .............................................................................. 9-25
Restrictions on Mutating Tables Relaxed ............................................................................. 9-26
System Trigger Restrictions.................................................................................................... 9-27
Foreign Function Callouts ...................................................................................................... 9-27
Who Uses the Trigger? ................................................................................................................... 9-27
Compiling Triggers .............................................................................................................................. 9-27
Dependencies for Triggers ............................................................................................................ 9-28
Recompiling Triggers .................................................................................................................... 9-28
Modifying Triggers............................................................................................................................... 9-29
Debugging Triggers.............................................................................................................................. 9-29
Enabling Triggers.................................................................................................................................. 9-29
Disabling Triggers................................................................................................................................. 9-29
Viewing Information About Triggers................................................................................................ 9-30
Examples of Trigger Applications ..................................................................................................... 9-31
Auditing with Triggers................................................................................................................... 9-31
Contraints and Triggers ................................................................................................................. 9-35
Referential Integrity Using Triggers............................................................................................. 9-36
Foreign Key Trigger for Child Table..................................................................................... 9-37
UPDATE and DELETE RESTRICT Trigger for Parent Table ............................................ 9-37
UPDATE and DELETE SET NULL Triggers for Parent Table .......................................... 9-38
xiv
DELETE Cascade Trigger for Parent Table.......................................................................... 9-39
UPDATE Cascade Trigger for Parent Table......................................................................... 9-39
Trigger for Complex Check Constraints............................................................................... 9-40
Complex Security Authorizations and Triggers.................................................................. 9-41
Transparent Event Logging and Triggers ............................................................................ 9-42
Derived Column Values and Triggers.................................................................................. 9-42
Building Complex Updatable Views Using Triggers ......................................................... 9-43
Fine-Grained Access Control Using Triggers ...................................................................... 9-44
Responding to Database Events Through Triggers........................................................................ 9-45
How Events Are Published Through Triggers ........................................................................... 9-45
Publication Context......................................................................................................................... 9-46
Error Handling ................................................................................................................................ 9-46
Execution Model.............................................................................................................................. 9-46
Event Attribute Functions.............................................................................................................. 9-46
Database Events .............................................................................................................................. 9-50
Client Events.................................................................................................................................... 9-51
10 Using PL/SQL Packages
What is a PL/SQL Package?................................................................................................................. 10-1
What Goes in a PL/SQL Package?...................................................................................................... 10-2
Advantages of PL/SQL Packages........................................................................................................ 10-3
Understanding the PL/SQL Package Specification........................................................................ 10-3
Referencing PL/SQL Package Contents............................................................................................ 10-4
Understanding the PL/SQL Package Body....................................................................................... 10-5
Examples of PL/SQL Package Features............................................................................................. 10-6
Private and Public Items in PL/SQL Packages................................................................................ 10-9
How STANDARD Package Defines the PL/SQL Environment................................................... 10-9
Overview of Product-Specific PL/SQL Packages.......................................................................... 10-10
DBMS_ALERT Package................................................................................................................ 10-10
DBMS_OUTPUT Package ............................................................................................................ 10-10
DBMS_PIPE Package .................................................................................................................... 10-11
DBMS_CONNECTION_POOL Package ................................................................................... 10-11
HTF and HTP Packages ............................................................................................................... 10-11
UTL_FILE Package........................................................................................................................ 10-11
UTL_HTTP Package ..................................................................................................................... 10-11
UTL_SMTP Package ..................................................................................................................... 10-11
Guidelines for Writing PL/SQL Packages...................................................................................... 10-12
Separating Cursor Specifications and Bodies with PL/SQL Packages..................................... 10-12
11 Handling PL/SQL Errors
Overview of PL/SQL Run-Time Error Handling............................................................................ 11-1
Guidelines for Avoiding and Handling PL/SQL Errors and Exceptions.................................... 11-2
Advantages of PL/SQL Exceptions.................................................................................................... 11-3
Predefined PL/SQL Exceptions........................................................................................................... 11-4
Defining Your Own PL/SQL Exceptions.......................................................................................... 11-6
Declaring PL/SQL Exceptions ...................................................................................................... 11-6
xv
12 xvi
Scope Rules for PL/SQL Exceptions ............................................................................................ 11-6
Associating a PL/SQL Exception with a Number (EXCEPTION_INIT Pragma) ................. 11-7
Defining Your Own Error Messages (RAISE_APPLICATION_ERROR Procedure) ............ 11-8
Redeclaring Predefined Exceptions.............................................................................................. 11-9
How PL/SQL Exceptions Are Raised................................................................................................. 11-9
How PL/SQL Exceptions Propagate................................................................................................. 11-10
Reraising a PL/SQL Exception.......................................................................................................... 11-12
Handling Raised PL/SQL Exceptions.............................................................................................. 11-13
Exceptions Raised in Declarations.............................................................................................. 11-14
Handling Exceptions Raised in Exception Handlers............................................................... 11-14
Branching To or from an Exception Handler............................................................................ 11-15
Retrieving the Error Code and Error Message ......................................................................... 11-15
Catching Unhandled Exceptions ................................................................................................ 11-16
Guidelines for Handling PL/SQL Errors .................................................................................. 11-16
Continuing Execution After an Exception Is Raised......................................................... 11-16
Retrying a Transaction .......................................................................................................... 11-17
Using Locator Variables to Identify Exception Locations................................................ 11-18
Overview of PL/SQL Compile-Time Warnings............................................................................. 11-19
PL/SQL Warning Categories ...................................................................................................... 11-19
Controlling PL/SQL Warning Messages................................................................................... 11-20
Using DBMS_WARNING Package ............................................................................................ 11-20
Tuning PL/SQL Applications for Performance
How PL/SQL Optimizes Your Programs........................................................................................... 12-1
When to Tune PL/SQL Code................................................................................................................ 12-2
Guidelines for Avoiding PL/SQL Performance Problems............................................................ 12-3
Avoiding CPU Overhead in PL/SQL Code................................................................................ 12-3
Make SQL Statements as Efficient as Possible..................................................................... 12-3
Make Function Calls as Efficient as Possible ....................................................................... 12-4
Make Loops as Efficient as Possible ...................................................................................... 12-5
Use Built-In String Functions ................................................................................................. 12-5
Put Least Expensive Conditional Tests First........................................................................ 12-5
Minimize Data Type Conversions......................................................................................... 12-5
Use PLS_INTEGER or SIMPLE_INTEGER for Integer Arithmetic .................................. 12-6
Use BINARY_FLOAT, BINARY_DOUBLE, SIMPLE_FLOAT, and SIMPLE_DOUBLE for
Floating-Point Arithmetic 12-6
Avoiding Memory Overhead in PL/SQL Code ......................................................................... Declare VARCHAR2 Variables of 4000 or More Characters ............................................. Group Related Subprograms into Packages ........................................................................ Pin Packages in the Shared Memory Pool............................................................................ Apply Advice of Compiler Warnings................................................................................... Collecting Data About User-Defined Identifiers............................................................................ Profiling and Tracing PL/SQL Programs.......................................................................................... Using the Profiler API: Package DBMS_PROFILER .................................................................. Using the Trace API: Package DBMS_TRACE............................................................................ Reducing Loop Overhead for DML Statements and Queries with Bulk SQL.......................... Running One DML Statement Multiple Times (FORALL Statement) .................................. 12-7
12-7
12-7
12-7
12-7
12-7
12-8
12-8
12-9
12-9
12-10
How FORALL Affects Rollbacks ......................................................................................... 12-14
Counting Rows Affected by FORALL (%BULK_ROWCOUNT Attribute) .................. 12-14
Handling FORALL Exceptions (%BULK_EXCEPTIONS Attribute).............................. 12-16
Retrieving Query Results into Collections (BULK COLLECT Clause) ................................. 12-17
Examples of Bulk Fetching from a Cursor ......................................................................... 12-19
Limiting Rows for a Bulk FETCH Operation (LIMIT Clause)......................................... 12-20
Retrieving DML Results Into a Collection (RETURNING INTO Clause) ..................... 12-21
Using FORALL and BULK COLLECT Together............................................................... 12-21
Using Host Arrays with Bulk Binds.................................................................................... 12-22
SELECT BULK COLLECT INTO Statements and Aliasing............................................. 12-22
Writing Computation-Intensive PL/SQL Programs...................................................................... 12-27
Tuning Dynamic SQL with EXECUTE IMMEDIATE Statement and Cursor Variables....... 12-27
Tuning PL/SQL Subprogram Calls with NOCOPY Hint............................................................ 12-28
Compiling PL/SQL Units for Native Execution............................................................................ 12-30
Determining Whether to Use PL/SQL Native Compilation .................................................. 12-30
How PL/SQL Native Compilation Works................................................................................ 12-31
Dependencies, Invalidation, and Revalidation......................................................................... 12-31
Setting Up a New Database for PL/SQL Native Compilation............................................... 12-31
Compiling the Entire Database for PL/SQL Native or Interpreted Compilation ............... 12-32
Performing Multiple Transformations with Pipelined Table Functions.................................. 12-34
Overview of Pipelined Table Functions..................................................................................... 12-34
Writing a Pipelined Table Function............................................................................................ 12-35
Using Pipelined Table Functions for Transformations............................................................ 12-36
Returning Results from Pipelined Table Functions ................................................................. 12-37
Pipelining Data Between PL/SQL Table Functions................................................................. 12-37
Optimizing Multiple Calls to Pipelined Table Functions........................................................ 12-38
Fetching from Results of Pipelined Table Functions ............................................................... 12-38
Passing Data with Cursor Variables........................................................................................... 12-38
Performing DML Operations Inside Pipelined Table Functions ........................................... 12-41
Performing DML Operations on Pipelined Table Functions.................................................. 12-41
Handling Exceptions in Pipelined Table Functions................................................................. 12-42
13 PL/SQL Language Elements
Assignment Statement......................................................................................................................... 13-3
AUTONOMOUS_TRANSACTION Pragma................................................................................... 13-6
Block........................................................................................................................................................ 13-8
CASE Statement................................................................................................................................... 13-15
CLOSE Statement................................................................................................................................ 13-18
Collection.............................................................................................................................................. 13-19
Collection Method Call...................................................................................................................... 13-23
Comment............................................................................................................................................... 13-27
Constant................................................................................................................................................ 13-28
CONTINUE Statement....................................................................................................................... 13-31
Cursor Attribute................................................................................................................................... 13-32
Cursor Variable Declaration.............................................................................................................. 13-34
EXCEPTION_INIT Pragma............................................................................................................... 13-38
Exception Declaration......................................................................................................................... 13-39
xvii
14 Exception Handler............................................................................................................................... 13-40
EXECUTE IMMEDIATE Statement................................................................................................. 13-42
EXIT Statement.................................................................................................................................... 13-45
Explicit Cursor..................................................................................................................................... 13-47
Expression............................................................................................................................................. 13-51
FETCH Statement................................................................................................................................ 13-60
FORALL Statement............................................................................................................................. 13-63
Function Declaration and Definition.............................................................................................. 13-66
GOTO Statement................................................................................................................................. 13-70
IF Statement.......................................................................................................................................... 13-71
INLINE Pragma................................................................................................................................... 13-73
Literal..................................................................................................................................................... 13-76
LOOP Statements................................................................................................................................ 13-79
NULL Statement.................................................................................................................................. 13-84
OPEN Statement.................................................................................................................................. 13-85
OPEN-FOR Statement........................................................................................................................ 13-87
Parameter Declaration........................................................................................................................ 13-90
Procedure Declaration and Definition............................................................................................ 13-92
RAISE Statement................................................................................................................................. 13-94
Record Definition................................................................................................................................ 13-95
RESTRICT_REFERENCES Pragma................................................................................................. 13-98
RETURN Statement.......................................................................................................................... 13-100
RETURNING INTO Clause............................................................................................................ 13-102
%ROWTYPE Attribute..................................................................................................................... 13-105
SELECT INTO Statement................................................................................................................ 13-107
SERIALLY_REUSABLE Pragma..................................................................................................... 13-111
SQL (Implicit) Cursor Attribute..................................................................................................... 13-113
SQLCODE Function......................................................................................................................... 13-116
SQLERRM Function......................................................................................................................... 13-117
%TYPE Attribute............................................................................................................................... 13-119
Variable................................................................................................................................................ 13-121
SQL Statements for Stored PL/SQL Units
ALTER FUNCTION Statement .......................................................................................................... 14-3
ALTER PACKAGE Statement ............................................................................................................ 14-6
ALTER PROCEDURE Statement ...................................................................................................... 14-9
ALTER TRIGGER Statement ........................................................................................................... 14-11
ALTER TYPE Statement .................................................................................................................... 14-14
CREATE FUNCTION Statement...................................................................................................... 14-27
CREATE PACKAGE Statement........................................................................................................ 14-36
CREATE PACKAGE BODY Statement .......................................................................................... 14-39
CREATE PROCEDURE Statement................................................................................................... 14-42
CREATE TRIGGER Statement......................................................................................................... 14-47
CREATE TYPE Statement ................................................................................................................. 14-60
CREATE TYPE BODY Statement .................................................................................................... 14-77
DROP FUNCTION Statement.......................................................................................................... 14-82
DROP PACKAGE Statement............................................................................................................ 14-84
xviii
DROP PROCEDURE Statement....................................................................................................... 14-86
DROP TRIGGER Statement............................................................................................................. 14-87
DROP TYPE Statement...................................................................................................................... 14-88
DROP TYPE BODY Statement......................................................................................................... 14-90
A Wrapping PL/SQL Source Code
Overview of Wrapping........................................................................................................................... A-1
Guidelines for Wrapping....................................................................................................................... A-1
Limitations of Wrapping........................................................................................................................ A-2
Wrapping PL/SQL Code with wrap Utility........................................................................................ A-2
Input and Output Files for the PL/SQL wrap Utility.................................................................. A-3
Running the wrap Utility................................................................................................................. A-3
Limitations of the wrap Utility........................................................................................................ A-4
Wrapping PL/QL Code with DBMS_DDL Subprograms................................................................ A-4
Using DBMS_DDL.CREATE_WRAPPED Procedure.................................................................. A-5
Limitation of the DBMS_DDL.WRAP Function ........................................................................... A-6
B How PL/SQL Resolves Identifier Names
What is Name Resolution?.................................................................................................................... B-1
Examples of Qualified Names and Dot Notation............................................................................. B-2
How Name Resolution Differs in PL/SQL and SQL........................................................................ B-4
What is Capture?...................................................................................................................................... B-4
Inner Capture..................................................................................................................................... B-4
Same-Scope Capture......................................................................................................................... B-5
Outer Capture.................................................................................................................................... B-5
Avoiding Inner Capture in DML Statements.................................................................................... B-5
Qualifying References to Attributes and Methods....................................................................... B-6
Qualifying References to Row Expressions................................................................................... B-7
C PL/SQL Program Limits
D PL/SQL Reserved Words and Keywords
Index
xix
xx
List of Examples
11 PL/SQL Block Structure ............................................................................................................ 1-4
12 PL/SQL Variable Declarations ................................................................................................. 1-7
13 Assigning Values to Variables with the Assignment Operator ........................................... 1-7
14 Using SELECT INTO to Assign Values to Variables ............................................................. 1-8
15 Assigning Values to Variables as Parameters of a Subprogram.......................................... 1-8
16 Using %ROWTYPE with an Explicit Cursor........................................................................ 1-10
17 Using a PL/SQL Collection Type.......................................................................................... 1-11
18 Declaring a Record Type......................................................................................................... 1-12
19 Defining an Object Type ......................................................................................................... 1-13
110 Using the IF-THEN-ELSE and CASE Statement for Conditional Control ...................... 1-14
111 Using the FOR-LOOP.............................................................................................................. 1-15
112 Using WHILE-LOOP for Control .......................................................................................... 1-15
113 Using the EXIT-WHEN Statement ........................................................................................ 1-16
114 Using the GOTO Statement.................................................................................................... 1-17
115 PL/SQL Procedure .................................................................................................................. 1-17
116 Creating a Standalone PL/SQL Procedure .......................................................................... 1-18
117 Invoking a Standalone Procedure from SQL*Plus.............................................................. 1-19
118 Creating a Trigger.................................................................................................................... 1-20
119 Creating a Package and Package Body................................................................................. 1-20
120 Invoking a Procedure in a Package ....................................................................................... 1-22
121 Processing Query Results in a LOOP.................................................................................... 1-23
21 NUMBER Literals ....................................................................................................................... 2-7
22 Using BINARY_FLOAT and BINARY_DOUBLE.................................................................. 2-7
23 Using DateTime Literals ............................................................................................................ 2-8
24 Single-Line Comments ............................................................................................................... 2-9
25 Multiline Comment ................................................................................................................. 2-10
26 Declaring Variables.................................................................................................................. 2-11
27 Declaring Constants................................................................................................................. 2-11
28 Assigning Default Values to Variables with DEFAULT Keyword................................... 2-12
29 Declaring Variables with NOT NULL Constraint .............................................................. 2-12
210 Using %TYPE to Declare Variables of the Types of Other Variables............................... 2-13
211 Using %TYPE Incorrectly with NOT NULL Referenced Type ......................................... 2-13
212 Using %TYPE Correctly with NOT NULL Referenced Type............................................ 2-13
213 Using %TYPE to Declare Variables of the Types of Table Columns................................ 2-14
214 Using %ROWTYPE to Declare a Record that Represents a Table Row........................... 2-15
215 Declaring a Record that Represents a Subset of Table Columns ...................................... 2-15
216 Declaring a Record that Represents a Row from a Join ..................................................... 2-16
217 Assigning One Record to Another, Correctly and Incorrectly.......................................... 2-16
218 Using SELECT INTO for Aggregate Assignment ............................................................... 2-17
219 Using an Alias for an Expression Associated with %ROWTYPE ..................................... 2-17
220 Duplicate Identifiers in Same Scope...................................................................................... 2-19
221 Case Insensitivity of Identifiers ............................................................................................. 2-20
222 Using a Block Label for Name Resolution............................................................................ 2-20
223 Using a Subprogram Name for Name Resolution .............................................................. 2-21
224 Scope and Visibility of Identifiers ......................................................................................... 2-23
225 Qualifying a Redeclared Global Identifier with a Block Label.......................................... 2-23
226 Qualifying an Identifier with a Subprogram Name ........................................................... 2-24
227 Label and Subprogram with Same Name in Same Scope.................................................. 2-25
228 Block with Multiple and Duplicate Labels........................................................................... 2-25
229 Variable Initialized to NULL by Default .............................................................................. 2-26
230 Assigning BOOLEAN Values ................................................................................................ 2-27
231 Assigning Query Results to Variables .................................................................................. 2-27
232 Concatenation Operator.......................................................................................................... 2-28
233 Operator Precedence ............................................................................................................... 2-29
xxi
234 AND Operator.......................................................................................................................... 2-30
235 OR Operator.............................................................................................................................. 2-31
236 NOT Operator .......................................................................................................................... 2-32
237 Changing Order of Evaluation of Logical Operators ......................................................... 2-33
238 Short-Circuit Evaluation ......................................................................................................... 2-34
239 Relational Operators................................................................................................................ 2-35
240 LIKE Operator .......................................................................................................................... 2-36
241 Escape Character in Pattern.................................................................................................... 2-36
242 BETWEEN Operator................................................................................................................ 2-37
243 IN Operator............................................................................................................................... 2-37
244 Using the IN Operator with Sets with NULL Values......................................................... 2-38
245 Using BOOLEAN Variables in Conditional Tests............................................................... 2-40
246 Using the WHEN Clause with a CASE Statement.............................................................. 2-41
247 Using a Search Condition with a CASE Statement ............................................................. 2-41
248 NULL Value in Unequal Comparison .................................................................................. 2-43
249 NULL Value in Equal Comparison ....................................................................................... 2-43
250 NULL Value as Argument to DECODE Function .............................................................. 2-45
251 NULL Value as Argument to NVL Function....................................................................... 2-45
252 NULL Value as Second Argument to REPLACE Function ............................................... 2-46
253 NULL Value as Third Argument to REPLACE Function .................................................. 2-46
254 Using Static Constants............................................................................................................. 2-52
255 Using DBMS_DB_VERSION Constants ............................................................................... 2-53
256 Using Conditional Compilation with Database Versions.................................................. 2-54
257 Using PRINT_POST_PROCESSED_SOURCE to Display Source Code .......................... 2-55
31 Comparing Two CHAR Values ............................................................................................. 3-10
32 Comparing Two VARCHAR2 Values................................................................................... 3-11
33 Comparing CHAR Value and VARCHAR2 Value ............................................................. 3-11
34 Assigning a Literal Value to a TIMESTAMP Variable ....................................................... 3-17
35 Using the SCN_TO_TIMESTAMP and TIMESTAMP_TO_SCN Functions.................... 3-17
36 Assigning a Literal to a TIMESTAMP WITH TIME ZONE Variable............................... 3-18
37 Correct Assignment to TIMESTAMP WITH LOCAL TIME ZONE................................. 3-19
38 Incorrect Assigment to TIMESTAMP WITH LOCAL TIME ZONE................................. 3-20
39 Assigning Literals to an INTERVAL YEAR TO MONTH Variable ................................. 3-20
310 Assigning Literals to an INTERVAL DAY TO SECOND Variable .................................. 3-21
311 Using Ranges with Subtypes.................................................................................................. 3-25
312 Type Compatibility with the NUMBER Data Type............................................................ 3-26
313 Assigning Default Value to Subtype Variable..................................................................... 3-26
314 Subtype Constraints Inherited by Subprograms................................................................. 3-27
315 Column Constraints Inherited by Subtypes......................................................................... 3-27
316 Implicit Conversion ................................................................................................................. 3-29
41 Simple IF-THEN Statement ....................................................................................................... 4-2
42 Using a Simple IF-THEN-ELSE Statement.............................................................................. 4-3
43 Nested IF-THEN-ELSE Statements .......................................................................................... 4-3
44 Using the IF-THEN-ELSIF Statement ...................................................................................... 4-4
45 Extended IF-THEN Statement ................................................................................................. 4-4
46 Simple CASE Statement ............................................................................................................. 4-5
47 Searched CASE Statement ......................................................................................................... 4-6
48 Using EXCEPTION Instead of ELSE Clause in CASE Statement ........................................ 4-7
49 EXIT Statement............................................................................................................................ 4-9
410 Using an EXIT-WHEN Statement.......................................................................................... 4-10
411 CONTINUE Statement............................................................................................................ 4-11
412 CONTINUE-WHEN Statement ............................................................................................. 4-11
413 Labeled Loops .......................................................................................................................... 4-12
414 Simple FOR-LOOP Statement................................................................................................ 4-14
415 Reverse FOR-LOOP Statement .............................................................................................. 4-14
xxii
416 Several Types of FOR-LOOP Bounds ................................................................................... 4-15
417 Changing the Increment of the Counter in a FOR-LOOP Statement ............................... 4-16
418 Specifying a LOOP Range at Run Time................................................................................ 4-16
419 FOR-LOOP with Lower Bound > Upper Bound................................................................. 4-16
420 Referencing Counter Variable Outside Loop....................................................................... 4-17
421 Using Existing Variable as Loop Variable............................................................................ 4-18
422 Referencing Global Variable with Same Name as Loop Counter..................................... 4-18
423 Referencing Outer Counter with Same Name as Inner Counter ...................................... 4-18
424 EXIT in a FOR LOOP............................................................................................................... 4-19
425 EXIT with a Label in a FOR LOOP ........................................................................................ 4-19
426 Simple GOTO Statement......................................................................................................... 4-20
427 Incorrect Label Placement....................................................................................................... 4-21
428 Using a NULL Statement to Allow a GOTO to a Label ..................................................... 4-21
429 Using a GOTO Statement to Branch to an Enclosing Block............................................... 4-22
430 GOTO Statement Cannot Branch into IF Statement ........................................................... 4-22
431 Using the NULL Statement to Show No Action.................................................................. 4-23
432 Using NULL as a Placeholder When Creating a Subprogram.......................................... 4-24
433 Using the NULL Statement in WHEN OTHER Clause...................................................... 4-24
51 Declaring and Using an Associative Array............................................................................. 5-2
52 Declaring an Associative Array ................................................................................................ 5-7
53 Declaring Nested Tables, Varrays, and Associative Arrays................................................. 5-8
54 Declaring Collections with %TYPE .......................................................................................... 5-8
55 Declaring a Procedure Parameter as a Nested Table............................................................. 5-9
56 Invoking a Procedure with a Nested Table Parameter ......................................................... 5-9
57 Specifying Collection Element Types with %TYPE and %ROWTYPE ............................... 5-9
58 VARRAY of Records................................................................................................................ 5-10
59 NOT NULL Constraint on Collection Elements.................................................................. 5-10
510 Constructor for a Nested Table.............................................................................................. 5-10
511 Constructor for a Varray......................................................................................................... 5-11
512 Collection Constructor Including Null Elements................................................................ 5-11
513 Combining Collection Declaration and Constructor .......................................................... 5-11
514 Empty Varray Constructor ..................................................................................................... 5-11
515 Referencing a Nested Table Element .................................................................................... 5-12
516 Referencing an Element of an Associative Array................................................................ 5-13
517 Data Type Compatibility for Collection Assignment ......................................................... 5-14
518 Assigning a Null Value to a Nested Table ........................................................................... 5-14
519 Assigning Nested Tables with Set Operators ...................................................................... 5-15
520 Assigning Values to VARRAYs with Complex Data Types.............................................. 5-15
521 Assigning Values to Tables with Complex Data Types ..................................................... 5-16
522 Checking if a Collection Is Null ............................................................................................. 5-17
523 Comparing Two Nested Tables ............................................................................................. 5-18
524 Comparing Nested Tables with Set Operators.................................................................... 5-18
525 Multilevel VARRAY ................................................................................................................ 5-19
526 Multilevel Nested Table.......................................................................................................... 5-19
527 Multilevel Associative Array ................................................................................................. 5-20
528 Checking Whether a Collection Element EXISTS................................................................ 5-21
529 Counting Collection Elements with COUNT ...................................................................... 5-22
530 Checking the Maximum Size of a Collection with LIMIT ................................................. 5-22
531 Using FIRST and LAST with a Collection ............................................................................ 5-23
532 Using PRIOR and NEXT to Access Collection Elements ................................................... 5-24
533 Using NEXT to Access Elements of a Nested Table ........................................................... 5-24
534 Using EXTEND to Increase the Size of a Collection ........................................................... 5-25
535 Using TRIM to Decrease the Size of a Collection ................................................................ 5-26
536 Using TRIM on Deleted Elements ......................................................................................... 5-27
537 Using the DELETE Method on a Collection......................................................................... 5-27
xxiii
538 Collection Exceptions .............................................................................................................. 5-28
539 How Invalid Subscripts are Handled with DELETE(n) ..................................................... 5-30
540 Incompatibility Between Package and Local Collection Types ........................................ 5-30
541 Declaring and Initializing a Simple Record Type ............................................................... 5-31
542 Declaring and Initializing Record Types.............................................................................. 5-31
543 Using %ROWTYPE to Declare a Record .............................................................................. 5-32
544 Returning a Record from a Function..................................................................................... 5-33
545 Using a Record as Parameter to a Procedure....................................................................... 5-33
546 Declaring a Nested Record ..................................................................................................... 5-34
547 Assigning Default Values to a Record .................................................................................. 5-34
548 Assigning All the Fields of a Record in One Statement ..................................................... 5-35
549 Using SELECT INTO to Assign Values in a Record ........................................................... 5-35
550 Inserting a PL/SQL Record Using %ROWTYPE ................................................................ 5-36
551 Updating a Row Using a Record ........................................................................................... 5-37
552 Using the RETURNING INTO Clause with a Record ........................................................ 5-37
553 Using BULK COLLECT with a SELECT INTO Statement................................................. 5-38
61 Data Manipulation with PL/SQL............................................................................................. 6-1
62 Checking SQL%ROWCOUNT After an UPDATE................................................................. 6-2
63 Substituting PL/SQL Variables ................................................................................................ 6-2
64 Invoking the SQL COUNT Function in PL/SQL ................................................................... 6-3
65 Using CURRVAL and NEXTVAL ............................................................................................ 6-4
66 Using ROWNUM........................................................................................................................ 6-6
67 Using SQL%FOUND .................................................................................................................. 6-8
68 Using SQL%ROWCOUNT ........................................................................................................ 6-8
69 Declaring a Cursor................................................................................................................... 6-10
610 Fetching with a Cursor............................................................................................................ 6-11
611 Referencing PL/SQL Variables Within Its Scope................................................................ 6-12
612 Fetching the Same Cursor Into Different Variables ............................................................ 6-12
613 Fetching Bulk Data with a Cursor ......................................................................................... 6-12
614 Using %FOUND....................................................................................................................... 6-14
615 Using %ISOPEN....................................................................................................................... 6-14
616 Using %NOTFOUND.............................................................................................................. 6-14
617 Using %ROWCOUNT............................................................................................................. 6-15
618 Using an Alias For Expressions in a Query.......................................................................... 6-19
619 Using a Subquery in a Cursor ................................................................................................ 6-19
620 Using a Subquery in a FROM Clause.................................................................................... 6-20
621 Using a Correlated Subquery................................................................................................. 6-21
622 Passing Parameters to a Cursor FOR Loop.......................................................................... 6-21
623 Passing Parameters to Explicit Cursors ................................................................................ 6-21
624 Cursor Variable Returning a %ROWTYPE Variable .......................................................... 6-24
625 Using the %ROWTYPE Attribute to Provide the Data Type............................................. 6-24
626 Cursor Variable Returning a Record Type........................................................................... 6-24
627 Passing a REF CURSOR as a Parameter ............................................................................... 6-24
628 Checking If a Cursor Variable is Open ................................................................................. 6-26
629 Stored Procedure to Open a Ref Cursor ............................................................................... 6-26
630 Stored Procedure to Open Ref Cursors with Different Queries........................................ 6-26
631 Cursor Variable with Different Return Types ..................................................................... 6-27
632 Fetching from a Cursor Variable into a Record................................................................... 6-28
633 Fetching from a Cursor Variable into Collections............................................................... 6-28
634 Declaration of Cursor Variables in a Package ..................................................................... 6-30
635 Using a Cursor Expression ..................................................................................................... 6-31
636 Using COMMIT with the WRITE Clause............................................................................. 6-33
637 Using ROLLBACK................................................................................................................... 6-34
638 Using SAVEPOINT with ROLLBACK.................................................................................. 6-35
639 reusing a SAVEPOINT with ROLLBACK............................................................................ 6-36
xxiv
640 Using SET TRANSACTION to Begin a Read-only Transaction ....................................... 6-37
641 Using CURRENT OF to Update the Latest Row Fetched from a Cursor ........................ 6-38
642 Fetching Across COMMITs Using ROWID ......................................................................... 6-40
643 Declaring an Autonomous Function in a Package.............................................................. 6-42
644 Declaring an Autonomous Standalone Procedure.............................................................. 6-42
645 Declaring an Autonomous PL/SQL Block........................................................................... 6-42
646 Declaring an Autonomous Trigger ....................................................................................... 6-43
647 Using Autonomous Triggers.................................................................................................. 6-45
648 Invoking an Autonomous Function ...................................................................................... 6-46
71 Invoking a Subprogram from a Dynamic PL/SQL Block..................................................... 7-3
72 Unsupported Data Type in Native Dynamic SQL ................................................................. 7-3
73 Uninitialized Variable for NULL in USING Clause .............................................................. 7-4
74 Native Dynamic SQL with OPEN-FOR, FETCH, and CLOSE Statements ........................ 7-4
75 Repeated Placeholder Names in Dynamic PL/SQL Block ................................................... 7-6
76 Switching from DBMS_SQL Package to Native Dynamic SQL ........................................... 7-7
77 Switching from Native Dynamic SQL to DBMS_SQL Package ........................................... 7-8
78 Setup for SQL Injection Examples ............................................................................................ 7-9
79 Procedure Vulnerable to Statement Modification............................................................... 7-10
710 Procedure Vulnerable to Statement Injection ...................................................................... 7-11
711 Procedure Vulnerable to SQL Injection Through Data Type Conversion....................... 7-13
712 Using Bind Arguments to Guard Against SQL Injection................................................... 7-14
713 Using Validation Checks to Guard Against SQL Injection................................................ 7-16
714 Using Explicit Format Models to Guard Against SQL Injection....................................... 7-17
81 Declaring, Defining, and Invoking a Simple PL/SQL Procedure ....................................... 8-3
82 Declaring, Defining, and Invoking a Simple PL/SQL Function.......................................... 8-5
83 Creating Nested Subprograms that Invoke Each Other........................................................ 8-6
84 Formal Parameters and Actual Parameters ............................................................................ 8-6
85 Using OUT Mode........................................................................................................................ 8-8
86 Procedure with Default Parameter Values........................................................................... 8-10
87 Formal Parameter with Expression as Default Value......................................................... 8-10
88 Subprogram Calls Using Positional, Named, and Mixed Notation ................................. 8-11
89 Overloading a Subprogram Name ........................................................................................ 8-12
810 Package Specification with Overloading Violation that Causes Compile-Time Error.. 8-15
811 Package Specification with Overloading Violation that Compiles Without Error ........ 8-15
812 Invocation of Improperly Overloaded Subprogram .......................................................... 8-15
813 Package Specification Without Overloading Violations .................................................... 8-16
814 Improper Invocation of Properly Overloaded Subprogram ............................................. 8-16
815 Resolving PL/SQL Procedure Names .................................................................................. 8-17
816 Creating an Object Type with AUTHID CURRENT USER ............................................... 8-21
817 Invoking an IR Instance Methods.......................................................................................... 8-22
818 Invoking an External Procedure from PL/SQL .................................................................. 8-24
819 Invoking a Java Function from PL/SQL .............................................................................. 8-24
820 RESTRICT_REFERENCES Pragma ....................................................................................... 8-25
821 Aliasing from Passing Global Variable with NOCOPY Hint............................................ 8-25
822 Aliasing Passing Same Parameter Multiple Times ............................................................. 8-26
823 Aliasing from Assigning Cursor Variables to Same Work Area....................................... 8-26
824 Declaration and Definition of Result-Cached Function ..................................................... 8-28
825 Result-Cached Function that Returns Configuration Parameter Setting ........................ 8-31
826.................................................................................................................................................... 8-33
827 Result-Cached Function that Depends on Session-Specific Application Context.......... 8-35
828 Caching One Name at a Time (Finer Granularity).............................................................. 8-36
829 Caching Translated Names One Language at a Time (Coarser Granularity)................. 8-36
91 CREATE TRIGGER Statement .................................................................................................. 9-5
92 Compound Trigger .................................................................................................................. 9-14
93 Compound Trigger Records Changes to One Table in Another Table............................ 9-16
xxv
94 Compound Trigger that Avoids Mutating-Table Error ..................................................... 9-18
95 Monitoring Logons with a Trigger........................................................................................ 9-19
96 Invoking a Java Subprogram from a Trigger....................................................................... 9-19
101 A Simple Package Specification Without a Body................................................................ 10-4
102 Matching Package Specifications and Bodies ...................................................................... 10-5
103 Creating the emp_admin Package......................................................................................... 10-6
104 Using PUT_LINE in the DBMS_OUTPUT Package.......................................................... 10-10
105 Separating Cursor Specifications with Packages .............................................................. 10-12
111 Run-Time Error Handling ...................................................................................................... 11-2
112 Managing Multiple Errors with a Single Exception Handler............................................ 11-3
113 Scope of PL/SQL Exceptions ................................................................................................. 11-7
114 Using PRAGMA EXCEPTION_INIT .................................................................................... 11-8
115 Raising an Application Error with RAISE_APPLICATION_ERROR .............................. 11-8
116 Using RAISE to Raise a User-Defined Exception................................................................ 11-9
117 Using RAISE to Raise a Predefined Exception .................................................................. 11-10
118 Scope of an Exception............................................................................................................ 11-12
119 Reraising a PL/SQL Exception ............................................................................................ 11-13
1110 Raising an Exception in a Declaration ................................................................................ 11-14
1111 Displaying SQLCODE and SQLERRM............................................................................... 11-15
1112 Continuing After an Exception ............................................................................................ 11-17
1113 Retrying a Transaction After an Exception ........................................................................ 11-18
1114 Using a Locator Variable to Identify the Location of an Exception................................ 11-18
1115 Controlling the Display of PL/SQL Warnings.................................................................. 11-20
1116 Using the DBMS_WARNING Package to Display Warnings ......................................... 11-20
121 Nesting a Query to Improve Performance........................................................................... 12-4
122 Issuing DELETE Statements in a Loop ............................................................................... 12-10
123 Issuing INSERT Statements in a Loop ................................................................................ 12-11
124 Using FORALL with Part of a Collection........................................................................... 12-11
125 Using FORALL with Nonconsecutive Index Values ........................................................ 12-12
126 Using Rollbacks with FORALL............................................................................................ 12-14
127 Using %BULK_ROWCOUNT with the FORALL Statement........................................... 12-14
128 Counting Rows Affected by FORALL with %BULK_ROWCOUNT ............................. 12-15
129 Bulk Operation that Continues Despite Exceptions ......................................................... 12-16
1210 Retrieving Query Results with BULK COLLECT ............................................................. 12-17
1211 Using the Pseudocolumn ROWNUM to Limit Query Results........................................ 12-18
1212 Bulk-Fetching from a Cursor Into One or More Collections ........................................... 12-19
1213 Bulk-Fetching from a Cursor Into a Collection of Records.............................................. 12-20
1214 Using LIMIT to Control the Number of Rows In a BULK COLLECT ........................... 12-20
1215 Using BULK COLLECT with the RETURNING INTO Clause ....................................... 12-21
1216 Using FORALL with BULK COLLECT .............................................................................. 12-21
1217 SELECT BULK COLLECT INTO Statement with Unexpected Results ......................... 12-22
1218 Workaround for Example 1217 Using a Cursor .............................................................. 12-23
1219 Workaround for Example 1217 Using a Second Collection........................................... 12-25
1220 Using NOCOPY with Parameters ....................................................................................... 12-28
1221 Assigning the Result of a Table Function........................................................................... 12-35
1222 Using a Pipelined Table Function For a Transformation................................................. 12-36
1223 Using Multiple REF CURSOR Input Variables ................................................................. 12-39
1224 Using a Pipelined Table Function as an Aggregate Function ......................................... 12-40
131 Specifying that a Subprogram Is To Be Inlined................................................................. 13-74
132 Specifying that an Overloaded Subprogram Is To Be Inlined......................................... 13-74
133 Specifying that a Subprogram Is Not To Be Inlined ......................................................... 13-75
134 Applying Two INLINE Pragmas to the Same Subprogram............................................ 13-75
135 Creating a Serially Reusable Package ............................................................................... 13-111
A1 Using DBMS_DDL.CREATE_WRAPPED Procedure to Wrap a Package......................... A-5
B1 Resolving Global and Local Variable Names ........................................................................ B-1
xxvi
B2 Using the Dot Notation to Qualify Names............................................................................. B-2
xxvii
List of Figures
11 PL/SQL Boosts Performance .................................................................................................... 1-2
12 PL/SQL Engine ........................................................................................................................ 1-24
41 Control Structures....................................................................................................................... 4-1
51 Array and Nested Table............................................................................................................. 5-5
52 Varray of Size 10.......................................................................................................................... 5-5
61 Transaction Control Flow ....................................................................................................... 6-41
81 How the PL/SQL Compiler Resolves Calls......................................................................... 8-17
101 Package Scope........................................................................................................................... 10-4
111 Propagation Rules: Example 1 ............................................................................................. 11-11
112 Propagation Rules: Example 2 ............................................................................................. 11-11
113 Propagation Rules: Example 3 ............................................................................................. 11-12
xxviii
List of Tables
11 PL/SQL Compilation Parameters ........................................................................................ 1-25
21 PL/SQL Delimiters.................................................................................................................... 2-3
22 Operator Precedence .............................................................................................................. 2-29
23 Logical Truth Table................................................................................................................. 2-30
24 Relational Operators............................................................................................................... 2-35
31 Categories of Predefined PL/SQL Data Types...................................................................... 3-1
32 Categories of Predefined PL/SQL Scalar Data Types.......................................................... 3-2
33 Predefined PL/SQL Numeric Data Types ............................................................................. 3-2
34 Predefined Subtypes of PLS_INTEGER Data Type .............................................................. 3-3
35 Predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE Constants ..................... 3-5
36 Predefined Subtypes of NUMBER Data Type ....................................................................... 3-7
37 Predefined PL/SQL Character Data Types............................................................................ 3-7
38 Comparison of AL16UTF16 and UTF8 Encodings............................................................. 3-13
39 Predefined PL/SQL Large Object (LOB) Data Types........................................................ 3-22
310 Possible Implicit PL/SQL Data Type Conversions............................................................ 3-31
51 Characteristics of PL/SQL Collection Types ......................................................................... 5-2
61 Cursor Attribute Values......................................................................................................... 6-15
81 Parameter Modes ....................................................................................................................... 8-9
82 PL/SQL Subprogram Parameter Notations........................................................................ 8-11
83 Comparison of Finer and Coarser Caching Granularity................................................... 8-35
91 Timing-Point Sections of a Compound Trigger Defined .................................................. 9-15
92 Comparison of Built-in Auditing and Trigger-Based Auditing...................................... 9-31
93 System-Defined Event Attributes........................................................................................ 9-47
94 Database Events ..................................................................................................................... 9-50
95 Client Events........................................................................................................................... 9-51
111 Predefined PL/SQL Exceptions............................................................................................ 11-4
112 PL/SQL Warning Categories .............................................................................................. 11-19
C1 PL/SQL Compiler Limits ........................................................................................................ C-1
D1 PL/SQL Reserved Words ........................................................................................................ D-1
D2 PL/SQL Keywords ................................................................................................................... D-2