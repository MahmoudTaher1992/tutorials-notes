Contents
Preface............................................................................................................................................................. xxxi
Audience................................................................................................................................................... xxxi
Documentation Accessibility................................................................................................................. xxxi
Related Documents ................................................................................................................................ xxxii
Conventions ............................................................................................................................................ xxxii
Syntax Descriptions............................................................................................................................... xxxiii
What's New in PL/SQL?....................................................................................................................... xxxv
xxxv
1-3
1-4
1-6
1-7
New PL/SQL Features for 11g Release 1 (11.1) ................................................................................ 1 Overview of PL/SQL
Advantages of PL/SQL............................................................................................................................ 1-1
Tight Integration with SQL............................................................................................................... 1-1
High Performance .............................................................................................................................. 1-2
High Productivity .............................................................................................................................. 1-2
Full Portability.................................................................................................................................... 1-3
Tight Security...................................................................................................................................... 1-3
Access to Predefined Packages......................................................................................................... 1-3
Support for Object-Oriented Programming ................................................................................... Support for Developing Web Applications and Server Pages .................................................... Main Features of PL/SQL........................................................................................................................ 1-4
PL/SQL Blocks ................................................................................................................................... 1-4
PL/SQL Error Handling ................................................................................................................... 1-5
PL/SQL Input and Output ............................................................................................................... PL/SQL Variables and Constants.................................................................................................... 1-6
Declaring PL/SQL Variables..................................................................................................... 1-6
Assigning Values to Variables .................................................................................................. Declaring PL/SQL Constants.................................................................................................... 1-9
Bind Variables ............................................................................................................................. 1-9
PL/SQL Data Abstraction................................................................................................................. 1-9
Cursors ...................................................................................................................................... 1-10
%TYPE Attribute...................................................................................................................... 1-10
%ROWTYPE Attribute ............................................................................................................ 1-10
Collections................................................................................................................................. 1-11
Records ...................................................................................................................................... 1-12
v
Object Types ............................................................................................................................. 1-12
PL/SQL Control Structures ........................................................................................................... 1-13
Conditional Control................................................................................................................. 1-13
Iterative Control ....................................................................................................................... 1-15
Sequential Control ................................................................................................................... 1-17
PL/SQL Subprograms.................................................................................................................... 1-17
Standalone PL/SQL Subprograms........................................................................................ 1-18
Triggers...................................................................................................................................... 1-19
PL/SQL Packages (APIs Written in PL/SQL) ............................................................................ 1-20
Conditional Compilation ............................................................................................................... 1-23
Embedded SQL Statements ........................................................................................................... 1-23
Architecture of PL/SQL........................................................................................................................ 1-24
PL/SQL Engine ............................................................................................................................... 1-24
PL/SQL Units and Compilation Parameters .............................................................................. 1-25
2 PL/SQL Language Fundamentals
Character Sets and Lexical Units........................................................................................................... 2-1
Delimiters ............................................................................................................................................ 2-3
Identifiers ............................................................................................................................................ 2-4
Reserved Words and Keywords ............................................................................................... 2-5
Predefined Identifiers................................................................................................................. 2-5
Quoted Identifiers....................................................................................................................... 2-5
Literals ................................................................................................................................................. 2-6
Numeric Literals.......................................................................................................................... 2-6
Character Literals........................................................................................................................ 2-7
String Literals............................................................................................................................... 2-7
BOOLEAN Literals ..................................................................................................................... 2-8
Date and Time Literals ............................................................................................................... 2-8
Comments ........................................................................................................................................... 2-9
Single-Line Comments ............................................................................................................... 2-9
Multiline Comments................................................................................................................ 2-10
Declarations............................................................................................................................................ 2-10
Variables ........................................................................................................................................... 2-11
Constants .......................................................................................................................................... 2-11
Using DEFAULT ............................................................................................................................. 2-11
Using NOT NULL........................................................................................................................... 2-12
Using the %TYPE Attribute........................................................................................................... 2-12
Using the %ROWTYPE Attribute ................................................................................................. 2-15
Aggregate Assignment............................................................................................................ 2-16
Using Aliases ............................................................................................................................ 2-17
Restrictions on Declarations .......................................................................................................... 2-18
Naming Conventions............................................................................................................................ 2-19
Scope ................................................................................................................................................. 2-19
Case Sensitivity................................................................................................................................ 2-20
Name Resolution............................................................................................................................. 2-20
Synonyms ......................................................................................................................................... 2-22
Scope and Visibility of PL/SQL Identifiers..................................................................................... 2-22
vi
Assigning Values to Variables............................................................................................................ 2-26
Assigning BOOLEAN Values........................................................................................................ 2-27
Assigning SQL Query Results to PL/SQL Variables................................................................. 2-27
PL/SQL Expressions and Comparisons............................................................................................. 2-28
Concatenation Operator................................................................................................................. 2-28
Operator Precedence....................................................................................................................... 2-28
Logical Operators............................................................................................................................ 2-30
Order of Evaluation ................................................................................................................. 2-33
Short-Circuit Evaluation ......................................................................................................... 2-34
Comparison Operators............................................................................................................ 2-34
IS NULL Operator ............................................................................................................ 2-35
LIKE Operator ................................................................................................................... 2-35
BETWEEN Operator......................................................................................................... 2-37
IN Operator ....................................................................................................................... 2-37
BOOLEAN Expressions ................................................................................................................. 2-38
BOOLEAN Arithmetic Expressions ...................................................................................... 2-38
BOOLEAN Character Expressions........................................................................................ 2-39
BOOLEAN Date Expressions................................................................................................. 2-39
Guidelines for BOOLEAN Expressions................................................................................ 2-40
CASE Expressions........................................................................................................................... 2-40
Simple CASE Expression ........................................................................................................ 2-41
Searched CASE Expression .................................................................................................... 2-41
Handling NULL Values in Comparisons and Conditional Statements.................................. 2-42
NULL Values and the NOT Operator................................................................................... 2-43
NULL Values and Zero-Length Strings................................................................................ 2-44
NULL Values and the Concatenation Operator.................................................................. 2-44
NULL Values as Arguments to Built-In Functions............................................................. 2-45
PL/SQL Error-Reporting Functions.................................................................................................... 2-47
Using SQL Functions in PL/SQL........................................................................................................ 2-47
Conditional Compilation..................................................................................................................... 2-48
How Does Conditional Compilation Work?............................................................................... 2-48
Conditional Compilation Control Tokens............................................................................ 2-48
Using Conditional Compilation Selection Directives......................................................... 2-49
Using Conditional Compilation Error Directives ............................................................... 2-49
Using Conditional Compilation Inquiry Directives ........................................................... 2-49
Using Predefined Inquiry Directives with Conditional Compilation.............................. 2-50
Using Static Expressions with Conditional Compilation................................................... 2-50
Boolean Static Expressions .............................................................................................. 2-51
PLS_INTEGER Static Expressions.................................................................................. 2-51
VARCHAR2 Static Expressions...................................................................................... 2-51
Static Constants................................................................................................................. 2-52
Using DBMS_DB_VERSION Package Constants................................................................ 2-53
Conditional Compilation Examples ............................................................................................. 2-54
Using Conditional Compilation to Specify Code for Database Versions ........................ 2-54
Using DBMS_PREPROCESSOR Procedures to Print or Retrieve Source Text ............... 2-55
Conditional Compilation Restrictions.......................................................................................... 2-55
Using PL/SQL to Create Web Applications...................................................................................... 2-56
vii
Using PL/SQL to Create Server Pages............................................................................................... 2-57
3 PL/SQL Data Types
Predefined PL/SQL Scalar Data Types and Subtypes....................................................................... 3-1
Predefined PL/SQL Numeric Data Types and Subtypes ............................................................ 3-2
PLS_INTEGER and BINARY_INTEGER Data Types............................................................ 3-2
SIMPLE_INTEGER Subtype of PLS_INTEGER ..................................................................... 3-3
Overflow Semantics............................................................................................................. 3-3
Overloading Rules............................................................................................................... 3-4
Integer Literals ..................................................................................................................... 3-4
Cast Operations.................................................................................................................... 3-5
Compiler Warnings ............................................................................................................. 3-5
BINARY_FLOAT and BINARY_DOUBLE Data Types ........................................................ 3-5
NUMBER Data Type .................................................................................................................. 3-6
Predefined PL/SQL Character Data Types and Subtypes........................................................... 3-7
CHAR and VARCHAR2 Data Types ...................................................................................... 3-8
Predefined Subtypes of Character Data Types................................................................ 3-9
Memory Allocation for Character Variables.................................................................... 3-9
Blank-Padding Shorter Character Values ..................................................................... 3-10
Comparing Character Values.......................................................................................... 3-10
Maximum Sizes of Values Inserted into Character Database Columns ................... 3-11
RAW Data Type ....................................................................................................................... 3-12
NCHAR and NVARCHAR2 Data Types ............................................................................. 3-12
AL16UTF16 and UTF8 Encodings.................................................................................. 3-12
NCHAR Data Type........................................................................................................... 3-13
NVARCHAR2 Data Type................................................................................................ 3-14
LONG and LONG RAW Data Types.................................................................................... 3-14
ROWID and UROWID Data Types....................................................................................... 3-14
Predefined PL/SQL BOOLEAN Data Type................................................................................ 3-15
Predefined PL/SQL Datetime and Interval Data Types ........................................................... 3-15
DATE Data Type...................................................................................................................... 3-16
TIMESTAMP Data Type ......................................................................................................... 3-17
TIMESTAMP WITH TIME ZONE Data Type ..................................................................... 3-18
TIMESTAMP WITH LOCAL TIME ZONE Data Type ...................................................... 3-19
INTERVAL YEAR TO MONTH Data Type......................................................................... 3-20
INTERVAL DAY TO SECOND Data Type.......................................................................... 3-20
Datetime and Interval Arithmetic ......................................................................................... 3-21
Avoiding Truncation Problems Using Date and Time Subtypes ..................................... 3-21
Predefined PL/SQL Large Object (LOB) Data Types..................................................................... 3-22
BFILE Data Type ............................................................................................................................. 3-23
BLOB Data Type.............................................................................................................................. 3-23
CLOB Data Type ............................................................................................................................. 3-23
NCLOB Data Type .......................................................................................................................... 3-23
User-Defined PL/SQL Subtypes......................................................................................................... 3-23
Defining Subtypes .......................................................................................................................... 3-24
Using Subtypes................................................................................................................................ 3-24
Type Compatibility with Subtypes ....................................................................................... 3-25
viii
4 5 Constraints and Default Values with Subtypes................................................................... 3-26
PL/SQL Data Type Conversion........................................................................................................... 3-28
Explicit Conversion......................................................................................................................... 3-28
Implicit Conversion ........................................................................................................................ 3-29
Using PL/SQL Control Structures
Overview of PL/SQL Control Structures............................................................................................. 4-1
Testing Conditions (IF and CASE Statements)................................................................................... 4-2
Using the IF-THEN Statement ......................................................................................................... 4-2
Using the IF-THEN-ELSE Statement............................................................................................... 4-2
Using the IF-THEN-ELSIF Statement.............................................................................................. 4-4
Using the Simple CASE Statement .................................................................................................. 4-5
Using the Searched CASE Statement .............................................................................................. 4-6
Guidelines for IF and CASE Statements ......................................................................................... 4-7
Controlling Loop Iterations (LOOP, EXIT, and CONTINUE Statements).................................... 4-8
Using the Basic LOOP Statement..................................................................................................... 4-9
Using the EXIT Statement ................................................................................................................. 4-9
Using the EXIT-WHEN Statement................................................................................................ 4-10
Using the CONTINUE Statement................................................................................................. 4-10
Using the CONTINUE-WHEN Statement .................................................................................. 4-11
Labeling a PL/SQL Loop ............................................................................................................... 4-12
Using the WHILE-LOOP Statement............................................................................................. 4-13
Using the FOR-LOOP Statement .................................................................................................. 4-13
How PL/SQL Loops Repeat................................................................................................... 4-15
Dynamic Ranges for Loop Bounds........................................................................................ 4-16
Scope of the Loop Counter Variable ..................................................................................... 4-17
Using the EXIT Statement in a FOR Loop ............................................................................ 4-19
Sequential Control (GOTO and NULL Statements)...................................................................... 4-20
Using the GOTO Statement ........................................................................................................... 4-20
GOTO Statement Restrictions ....................................................................................................... 4-22
Using the NULL Statement............................................................................................................ 4-23
Using PL/SQL Collections and Records
Understanding PL/SQL Collection Types........................................................................................... 5-1
Understanding Associative Arrays (Index-By Tables) ................................................................. 5-2
Understanding Nested Tables.......................................................................................................... 5-4
Understanding Variable-Size Arrays (Varrays)............................................................................. 5-5
Choosing PL/SQL Collection Types..................................................................................................... 5-5
Choosing Between Nested Tables and Associative Arrays ......................................................... 5-5
Choosing Between Nested Tables and Varrays............................................................................. 5-6
Defining Collection Types...................................................................................................................... 5-6
Declaring Collection Variables.............................................................................................................. 5-8
Initializing and Referencing Collections......................................................................................... 5-10
Referencing Collection Elements....................................................................................................... 5-12
Assigning Values to Collections......................................................................................................... 5-13
Comparing Collections......................................................................................................................... 5-17
ix
Using Multidimensional Collections................................................................................................ 5-19
Using Collection Methods................................................................................................................... 5-20
Checking If a Collection Element Exists (EXISTS Method) ...................................................... 5-21
Counting the Elements in a Collection (COUNT Method) ....................................................... 5-21
Checking the Maximum Size of a Collection (LIMIT Method) ................................................ 5-22
Finding the First or Last Collection Element (FIRST and LAST Methods) ............................ 5-22
Looping Through Collection Elements (PRIOR and NEXT Methods).................................... 5-23
Increasing the Size of a Collection (EXTEND Method) ............................................................. 5-24
Decreasing the Size of a Collection (TRIM Method).................................................................. 5-26
Deleting Collection Elements (DELETE Method) ...................................................................... 5-27
Applying Methods to Collection Parameters.............................................................................. 5-28
Avoiding Collection Exceptions......................................................................................................... 5-28
Defining and Declaring Records........................................................................................................ 5-31
Using Records as Subprogram Parameters and Function Return Values.................................. 5-33
Assigning Values to Records............................................................................................................... 5-34
Comparing Records ........................................................................................................................ 5-36
Inserting Records Into the Database............................................................................................. 5-36
Updating the Database with Record Values ............................................................................... 5-36
Restrictions on Record Inserts and Updates ............................................................................... 5-38
Querying Data Into Collections of Records................................................................................. 5-38
6 Using Static SQL
Description of Static SQL....................................................................................................................... 6-1
Data Manipulation Language (DML) Statements ......................................................................... 6-1
Transaction Control Language (TCL) Statements......................................................................... 6-3
SQL Functions..................................................................................................................................... 6-3
SQL Pseudocolumns.......................................................................................................................... 6-4
CURRVAL and NEXTVAL........................................................................................................ 6-4
LEVEL........................................................................................................................................... 6-5
ROWID ......................................................................................................................................... 6-5
ROWNUM ................................................................................................................................... 6-6
SQL Operators .................................................................................................................................... 6-6
Comparison Operators............................................................................................................... 6-6
Set Operators ............................................................................................................................... 6-7
Row Operators ............................................................................................................................ 6-7
Managing Cursors in PL/SQL................................................................................................................ 6-7
SQL Cursors (Implicit) ...................................................................................................................... 6-7
Attributes of SQL Cursors ......................................................................................................... 6-8
%FOUND Attribute: Has a DML Statement Changed Rows?...................................... 6-8
%ISOPEN Attribute: Always FALSE for SQL Cursors .................................................. 6-8
%NOTFOUND Attribute: Has a DML Statement Failed to Change Rows? ............... 6-8
%ROWCOUNT Attribute: How Many Rows Affected So Far?.................................... 6-8
Guidelines for Using Attributes of SQL Cursors ................................................................... 6-9
Explicit Cursors .................................................................................................................................. 6-9
Declaring a Cursor................................................................................................................... 6-10
Opening a Cursor..................................................................................................................... 6-11
Fetching with a Cursor............................................................................................................ 6-11
x
Fetching Bulk Data with a Cursor ......................................................................................... 6-12
Closing a Cursor....................................................................................................................... 6-13
Attributes of Explicit Cursors ................................................................................................ 6-13
%FOUND Attribute: Has a Row Been Fetched? .......................................................... 6-13
%ISOPEN Attribute: Is the Cursor Open? .................................................................... 6-14
%NOTFOUND Attribute: Has a Fetch Failed?............................................................. 6-14
%ROWCOUNT Attribute: How Many Rows Fetched So Far? .................................. 6-15
Querying Data with PL/SQL............................................................................................................... 6-16
Selecting At Most One Row (SELECT INTO Statement) .......................................................... 6-16
Selecting Multiple Rows (BULK COLLECT Clause) ................................................................. 6-17
Looping Through Multiple Rows (Cursor FOR Loop).............................................................. 6-17
Performing Complicated Query Processing (Explicit Cursors) ............................................... 6-17
Cursor FOR LOOP .......................................................................................................................... 6-18
SQL Cursor FOR LOOP .......................................................................................................... 6-18
Explicit Cursor FOR LOOP..................................................................................................... 6-18
Defining Aliases for Expression Values in a Cursor FOR Loop............................................... 6-19
Using Subqueries.................................................................................................................................. 6-19
Using Correlated Subqueries......................................................................................................... 6-20
Writing Maintainable PL/SQL Subqueries................................................................................. 6-21
Using Cursor Variables (REF CURSORs)......................................................................................... 6-22
What Are Cursor Variables (REF CURSORs)?............................................................................ 6-23
Why Use Cursor Variables?........................................................................................................... 6-23
Declaring REF CURSOR Types and Cursor Variables .............................................................. 6-23
Passing Cursor Variables As Parameters .................................................................................... 6-24
Controlling Cursor Variables (OPEN-FOR, FETCH, and CLOSE Statements)...................... 6-25
Opening a Cursor Variable..................................................................................................... 6-25
Using a Cursor Variable as a Host Variable......................................................................... 6-27
Fetching from a Cursor Variable ........................................................................................... 6-28
Closing a Cursor Variable....................................................................................................... 6-29
Reducing Network Traffic When Passing Host Cursor Variables to PL/SQL ...................... 6-29
Avoiding Errors with Cursor Variables....................................................................................... 6-30
Restrictions on Cursor Variables .................................................................................................. 6-30
Using Cursor Expressions.................................................................................................................... 6-31
Overview of Transaction Processing in PL/SQL............................................................................. 6-32
Using COMMIT in PL/SQL .......................................................................................................... 6-33
Using ROLLBACK in PL/SQL...................................................................................................... 6-34
Using SAVEPOINT in PL/SQL .................................................................................................... 6-35
How the Database Does Implicit Rollbacks ................................................................................ 6-36
Ending Transactions ....................................................................................................................... 6-36
Setting Transaction Properties (SET TRANSACTION Statement) .......................................... 6-37
Overriding Default Locking .......................................................................................................... 6-37
Using FOR UPDATE ............................................................................................................... 6-38
Using LOCK TABLE................................................................................................................ 6-39
Fetching Across Commits....................................................................................................... 6-39
Doing Independent Units of Work with Autonomous Transactions.......................................... 6-40
Advantages of Autonomous Transactions .................................................................................. 6-41
Defining Autonomous Transactions ............................................................................................ 6-41
xi
Comparison of Autonomous Transactions and Nested Transactions ............................. 6-43
Transaction Context................................................................................................................. 6-43
Transaction Visibility............................................................................................................... 6-43
Controlling Autonomous Transactions ....................................................................................... 6-44
Entering and Exiting................................................................................................................ 6-44
Committing and Rolling Back................................................................................................ 6-44
Using Savepoints...................................................................................................................... 6-44
Avoiding Errors with Autonomous Transactions............................................................... 6-45
Using Autonomous Triggers......................................................................................................... 6-45
Invoking Autonomous Functions from SQL............................................................................... 6-46
7 Using Dynamic SQL
When You Need Dynamic SQL............................................................................................................. 7-1
Using Native Dynamic SQL................................................................................................................... 7-2
Using the EXECUTE IMMEDIATE Statement............................................................................... 7-2
Using the OPEN-FOR, FETCH, and CLOSE Statements ............................................................. 7-4
Repeating Placeholder Names in Dynamic SQL Statements....................................................... 7-5
Dynamic SQL Statement is Not Anonymous Block or CALL Statement ........................... 7-5
Dynamic SQL Statement is Anonymous Block or CALL Statement ................................... 7-5
Using DBMS_SQL Package................................................................................................................... 7-6
DBMS_SQL.TO_REFCURSOR Function ........................................................................................ 7-7
DBMS_SQL.TO_CURSOR_NUMBER Function............................................................................ 7-8
Avoiding SQL Injection in PL/SQL...................................................................................................... 7-9
Overview of SQL Injection Techniques .......................................................................................... 7-9
Statement Modification.............................................................................................................. 7-9
Statement Injection .................................................................................................................. 7-11
Data Type Conversion............................................................................................................. 7-12
Guarding Against SQL Injection................................................................................................... 7-14
Using Bind Arguments to Guard Against SQL Injection................................................... 7-14
Using Validation Checks to Guard Against SQL Injection................................................ 7-15
Using Explicit Format Models to Guard Against SQL Injection....................................... 7-17
8 Using PL/SQL Subprograms
Overview of PL/SQL Subprograms...................................................................................................... 8-1
Subprogram Parts..................................................................................................................................... 8-3
Creating Nested Subprograms that Invoke Each Other................................................................... 8-5
Declaring and Passing Subprogram Parameters................................................................................ 8-6
Formal and Actual Subprogram Parameters ................................................................................. 8-6
Specifying Subprogram Parameter Modes..................................................................................... 8-7
Using IN Mode............................................................................................................................ 8-8
Using OUT Mode........................................................................................................................ 8-8
Using IN OUT Mode .................................................................................................................. 8-9
Summary of Subprogram Parameter Modes .......................................................................... 8-9
Specifying Default Values for Subprogram Parameters .............................................................. 8-9
Passing Actual Subprogram Parameters with Positional, Named, or Mixed Notation ....... 8-11
Overloading PL/SQL Subprogram Names....................................................................................... 8-12
Guidelines for Overloading with Numeric Types ..................................................................... 8-13
xii
Restrictions on Overloading.......................................................................................................... 8-14
When Compiler Catches Overloading Errors............................................................................. 8-14
How PL/SQL Subprogram Calls Are Resolved............................................................................... 8-16
Using Invoker's Rights or Definer's Rights (AUTHID Clause)................................................... 8-18
Choosing Between AUTHID CURRENT_USER and AUTHID DEFINER............................. 8-19
AUTHID and the SQL Command SET ROLE............................................................................. 8-20
Need for Template Objects in IR Subprograms.......................................................................... 8-20
Overriding Default Name Resolution in IR Subprograms ....................................................... 8-20
Using Views and Database Triggers with IR Subprograms ..................................................... 8-20
Using Database Links with IR Subprograms.............................................................................. 8-20
Using Object Types with IR Subprograms .................................................................................. 8-21
Invoking IR Instance Methods ...................................................................................................... 8-22
Using Recursive PL/SQL Subprograms............................................................................................ 8-23
Invoking External Subprograms........................................................................................................ 8-23
Controlling Side Effects of PL/SQL Subprograms......................................................................... 8-24
Understanding PL/SQL Subprogram Parameter Aliasing............................................................ 8-25
Using the PL/SQL Function Result Cache........................................................................................ 8-27
Enabling Result-Caching for a Function...................................................................................... 8-28
Developing Applications with Result-Cached Functions......................................................... 8-29
Restrictions on Result-Cached Functions .................................................................................... 8-29
Examples of Result-Cached Functions......................................................................................... 8-30
Result-Cached Application Configuration Parameters...................................................... 8-30
Result-Cached Recursive Function........................................................................................ 8-32
Advanced Result-Cached Function Topics ................................................................................. 8-32
Rules for a Cache Hit............................................................................................................... 8-32
Bypassing the Result Cache.................................................................................................... 8-33
Making Result-Cached Functions Handle Session-Specific Settings ............................... 8-33
Making Result-Cached Functions Handle Session-Specific Application Contexts........ 8-34
Choosing Result-Caching Granularity.................................................................................. 8-35
Result Caches in Oracle RAC Environment......................................................................... 8-36
Managing the Result Cache.................................................................................................... 8-37
Hot-Patching PL/SQL Units on Which Result-Cached Functions Depend.................... 8-37
9 Using Triggers
Overview of Triggers............................................................................................................................... 9-1
Trigger Types...................................................................................................................................... 9-2
Trigger States ...................................................................................................................................... 9-2
Data Access for Triggers ................................................................................................................... 9-2
Uses of Triggers.................................................................................................................................. 9-3
Guidelines for Designing Triggers....................................................................................................... 9-3
Privileges Required to Use Triggers..................................................................................................... 9-4
Creating Triggers ..................................................................................................................................... 9-5
Naming Triggers ............................................................................................................................... 9-6
When Does the Trigger Fire? ........................................................................................................... 9-6
Do Import and SQL*Loader Fire Triggers?............................................................................. 9-6
How Column Lists Affect UPDATE Triggers ........................................................................ 9-7
Controlling When a Trigger Fires (BEFORE and AFTER Options) ........................................... 9-7
xiii
Ordering of Triggers.......................................................................................................................... 9-8
Modifying Complex Views (INSTEAD OF Triggers)................................................................... 9-8
Views that Require INSTEAD OF Triggers............................................................................. 9-9
Triggers on Nested Table View Columns ............................................................................... 9-9
Example: INSTEAD OF Trigger............................................................................................. 9-11
Firing Triggers One or Many Times (FOR EACH ROW Option) ........................................... 9-12
Firing Triggers Based on Conditions (WHEN Clause) ............................................................. 9-13
Compound Triggers........................................................................................................................ 9-13
Why Use Compound Triggers? ............................................................................................. 9-13
Compound Trigger Sections................................................................................................... 9-14
Triggering Statements of Compound Triggers.................................................................... 9-15
Compound Trigger Restrictions ............................................................................................ 9-15
Compound Trigger Example ................................................................................................. 9-16
Using Compound Triggers to Avoid Mutating-Table Error ............................................. 9-18
Coding the Trigger Body ..................................................................................................................... 9-18
Accessing Column Values in Row Triggers ............................................................................... 9-20
Example: Modifying LOB Columns with a Trigger............................................................ 9-20
INSTEAD OF Triggers on Nested Table View Columns ................................................... 9-21
Avoiding Trigger Name Conflicts (REFERENCING Option) .......................................... 9-21
Detecting the DML Operation that Fired a Trigger ............................................................ 9-22
Error Conditions and Exceptions in the Trigger Body ...................................................... 9-22
Triggers on Object Tables............................................................................................................... 9-22
Triggers and Handling Remote Exceptions ............................................................................... 9-23
Restrictions on Creating Triggers ................................................................................................ 9-24
Maximum Trigger Size............................................................................................................ 9-24
SQL Statements Allowed in Trigger Bodies......................................................................... 9-25
Trigger Restrictions on LONG and LONG RAW Data Types .......................................... 9-25
Trigger Restrictions on Mutating Tables .............................................................................. 9-25
Restrictions on Mutating Tables Relaxed ............................................................................. 9-26
System Trigger Restrictions.................................................................................................... 9-27
Foreign Function Callouts ...................................................................................................... 9-27
Who Uses the Trigger? ................................................................................................................... 9-27
Compiling Triggers .............................................................................................................................. 9-27
Dependencies for Triggers ............................................................................................................ 9-28
Recompiling Triggers .................................................................................................................... 9-28
Modifying Triggers............................................................................................................................... 9-29
Debugging Triggers.............................................................................................................................. 9-29
Enabling Triggers.................................................................................................................................. 9-29
Disabling Triggers................................................................................................................................. 9-29
Viewing Information About Triggers................................................................................................ 9-30
Examples of Trigger Applications ..................................................................................................... 9-31
Auditing with Triggers................................................................................................................... 9-31
Contraints and Triggers ................................................................................................................. 9-35
Referential Integrity Using Triggers............................................................................................. 9-36
Foreign Key Trigger for Child Table..................................................................................... 9-37
UPDATE and DELETE RESTRICT Trigger for Parent Table ............................................ 9-37
UPDATE and DELETE SET NULL Triggers for Parent Table .......................................... 9-38
xiv
DELETE Cascade Trigger for Parent Table.......................................................................... 9-39
UPDATE Cascade Trigger for Parent Table......................................................................... 9-39
Trigger for Complex Check Constraints............................................................................... 9-40
Complex Security Authorizations and Triggers.................................................................. 9-41
Transparent Event Logging and Triggers ............................................................................ 9-42
Derived Column Values and Triggers.................................................................................. 9-42
Building Complex Updatable Views Using Triggers ......................................................... 9-43
Fine-Grained Access Control Using Triggers ...................................................................... 9-44
Responding to Database Events Through Triggers........................................................................ 9-45
How Events Are Published Through Triggers ........................................................................... 9-45
Publication Context......................................................................................................................... 9-46
Error Handling ................................................................................................................................ 9-46
Execution Model.............................................................................................................................. 9-46
Event Attribute Functions.............................................................................................................. 9-46
Database Events .............................................................................................................................. 9-50
Client Events.................................................................................................................................... 9-51
10 Using PL/SQL Packages
What is a PL/SQL Package?................................................................................................................. 10-1
What Goes in a PL/SQL Package?...................................................................................................... 10-2
Advantages of PL/SQL Packages........................................................................................................ 10-3
Understanding the PL/SQL Package Specification........................................................................ 10-3
Referencing PL/SQL Package Contents............................................................................................ 10-4
Understanding the PL/SQL Package Body....................................................................................... 10-5
Examples of PL/SQL Package Features............................................................................................. 10-6
Private and Public Items in PL/SQL Packages................................................................................ 10-9
How STANDARD Package Defines the PL/SQL Environment................................................... 10-9
Overview of Product-Specific PL/SQL Packages.......................................................................... 10-10
DBMS_ALERT Package................................................................................................................ 10-10
DBMS_OUTPUT Package ............................................................................................................ 10-10
DBMS_PIPE Package .................................................................................................................... 10-11
DBMS_CONNECTION_POOL Package ................................................................................... 10-11
HTF and HTP Packages ............................................................................................................... 10-11
UTL_FILE Package........................................................................................................................ 10-11
UTL_HTTP Package ..................................................................................................................... 10-11
UTL_SMTP Package ..................................................................................................................... 10-11
Guidelines for Writing PL/SQL Packages...................................................................................... 10-12
Separating Cursor Specifications and Bodies with PL/SQL Packages..................................... 10-12
11 Handling PL/SQL Errors
Overview of PL/SQL Run-Time Error Handling............................................................................ 11-1
Guidelines for Avoiding and Handling PL/SQL Errors and Exceptions.................................... 11-2
Advantages of PL/SQL Exceptions.................................................................................................... 11-3
Predefined PL/SQL Exceptions........................................................................................................... 11-4
Defining Your Own PL/SQL Exceptions.......................................................................................... 11-6
Declaring PL/SQL Exceptions ...................................................................................................... 11-6
xv
12 xvi
Scope Rules for PL/SQL Exceptions ............................................................................................ 11-6
Associating a PL/SQL Exception with a Number (EXCEPTION_INIT Pragma) ................. 11-7
Defining Your Own Error Messages (RAISE_APPLICATION_ERROR Procedure) ............ 11-8
Redeclaring Predefined Exceptions.............................................................................................. 11-9
How PL/SQL Exceptions Are Raised................................................................................................. 11-9
How PL/SQL Exceptions Propagate................................................................................................. 11-10
Reraising a PL/SQL Exception.......................................................................................................... 11-12
Handling Raised PL/SQL Exceptions.............................................................................................. 11-13
Exceptions Raised in Declarations.............................................................................................. 11-14
Handling Exceptions Raised in Exception Handlers............................................................... 11-14
Branching To or from an Exception Handler............................................................................ 11-15
Retrieving the Error Code and Error Message ......................................................................... 11-15
Catching Unhandled Exceptions ................................................................................................ 11-16
Guidelines for Handling PL/SQL Errors .................................................................................. 11-16
Continuing Execution After an Exception Is Raised......................................................... 11-16
Retrying a Transaction .......................................................................................................... 11-17
Using Locator Variables to Identify Exception Locations................................................ 11-18
Overview of PL/SQL Compile-Time Warnings............................................................................. 11-19
PL/SQL Warning Categories ...................................................................................................... 11-19
Controlling PL/SQL Warning Messages................................................................................... 11-20
Using DBMS_WARNING Package ............................................................................................ 11-20
Tuning PL/SQL Applications for Performance
How PL/SQL Optimizes Your Programs........................................................................................... 12-1
When to Tune PL/SQL Code................................................................................................................ 12-2
Guidelines for Avoiding PL/SQL Performance Problems............................................................ 12-3
Avoiding CPU Overhead in PL/SQL Code................................................................................ 12-3
Make SQL Statements as Efficient as Possible..................................................................... 12-3
Make Function Calls as Efficient as Possible ....................................................................... 12-4
Make Loops as Efficient as Possible ...................................................................................... 12-5
Use Built-In String Functions ................................................................................................. 12-5
Put Least Expensive Conditional Tests First........................................................................ 12-5
Minimize Data Type Conversions......................................................................................... 12-5
Use PLS_INTEGER or SIMPLE_INTEGER for Integer Arithmetic .................................. 12-6
Use BINARY_FLOAT, BINARY_DOUBLE, SIMPLE_FLOAT, and SIMPLE_DOUBLE for
Floating-Point Arithmetic 12-6
Avoiding Memory Overhead in PL/SQL Code ......................................................................... Declare VARCHAR2 Variables of 4000 or More Characters ............................................. Group Related Subprograms into Packages ........................................................................ Pin Packages in the Shared Memory Pool............................................................................ Apply Advice of Compiler Warnings................................................................................... Collecting Data About User-Defined Identifiers............................................................................ Profiling and Tracing PL/SQL Programs.......................................................................................... Using the Profiler API: Package DBMS_PROFILER .................................................................. Using the Trace API: Package DBMS_TRACE............................................................................ Reducing Loop Overhead for DML Statements and Queries with Bulk SQL.......................... Running One DML Statement Multiple Times (FORALL Statement) .................................. 12-7
12-7
12-7
12-7
12-7
12-7
12-8
12-8
12-9
12-9
12-10
How FORALL Affects Rollbacks ......................................................................................... 12-14
Counting Rows Affected by FORALL (%BULK_ROWCOUNT Attribute) .................. 12-14
Handling FORALL Exceptions (%BULK_EXCEPTIONS Attribute).............................. 12-16
Retrieving Query Results into Collections (BULK COLLECT Clause) ................................. 12-17
Examples of Bulk Fetching from a Cursor ......................................................................... 12-19
Limiting Rows for a Bulk FETCH Operation (LIMIT Clause)......................................... 12-20
Retrieving DML Results Into a Collection (RETURNING INTO Clause) ..................... 12-21
Using FORALL and BULK COLLECT Together............................................................... 12-21
Using Host Arrays with Bulk Binds.................................................................................... 12-22
SELECT BULK COLLECT INTO Statements and Aliasing............................................. 12-22
Writing Computation-Intensive PL/SQL Programs...................................................................... 12-27
Tuning Dynamic SQL with EXECUTE IMMEDIATE Statement and Cursor Variables....... 12-27
Tuning PL/SQL Subprogram Calls with NOCOPY Hint............................................................ 12-28
Compiling PL/SQL Units for Native Execution............................................................................ 12-30
Determining Whether to Use PL/SQL Native Compilation .................................................. 12-30
How PL/SQL Native Compilation Works................................................................................ 12-31
Dependencies, Invalidation, and Revalidation......................................................................... 12-31
Setting Up a New Database for PL/SQL Native Compilation............................................... 12-31
Compiling the Entire Database for PL/SQL Native or Interpreted Compilation ............... 12-32
Performing Multiple Transformations with Pipelined Table Functions.................................. 12-34
Overview of Pipelined Table Functions..................................................................................... 12-34
Writing a Pipelined Table Function............................................................................................ 12-35
Using Pipelined Table Functions for Transformations............................................................ 12-36
Returning Results from Pipelined Table Functions ................................................................. 12-37
Pipelining Data Between PL/SQL Table Functions................................................................. 12-37
Optimizing Multiple Calls to Pipelined Table Functions........................................................ 12-38
Fetching from Results of Pipelined Table Functions ............................................................... 12-38
Passing Data with Cursor Variables........................................................................................... 12-38
Performing DML Operations Inside Pipelined Table Functions ........................................... 12-41
Performing DML Operations on Pipelined Table Functions.................................................. 12-41
Handling Exceptions in Pipelined Table Functions................................................................. 12-42
13 PL/SQL Language Elements
Assignment Statement......................................................................................................................... 13-3
AUTONOMOUS_TRANSACTION Pragma................................................................................... 13-6
Block........................................................................................................................................................ 13-8
CASE Statement................................................................................................................................... 13-15
CLOSE Statement................................................................................................................................ 13-18
Collection.............................................................................................................................................. 13-19
Collection Method Call...................................................................................................................... 13-23
Comment............................................................................................................................................... 13-27
Constant................................................................................................................................................ 13-28
CONTINUE Statement....................................................................................................................... 13-31
Cursor Attribute................................................................................................................................... 13-32
Cursor Variable Declaration.............................................................................................................. 13-34
EXCEPTION_INIT Pragma............................................................................................................... 13-38
Exception Declaration......................................................................................................................... 13-39
xvii
14 Exception Handler............................................................................................................................... 13-40
EXECUTE IMMEDIATE Statement................................................................................................. 13-42
EXIT Statement.................................................................................................................................... 13-45
Explicit Cursor..................................................................................................................................... 13-47
Expression............................................................................................................................................. 13-51
FETCH Statement................................................................................................................................ 13-60
FORALL Statement............................................................................................................................. 13-63
Function Declaration and Definition.............................................................................................. 13-66
GOTO Statement................................................................................................................................. 13-70
IF Statement.......................................................................................................................................... 13-71
INLINE Pragma................................................................................................................................... 13-73
Literal..................................................................................................................................................... 13-76
LOOP Statements................................................................................................................................ 13-79
NULL Statement.................................................................................................................................. 13-84
OPEN Statement.................................................................................................................................. 13-85
OPEN-FOR Statement........................................................................................................................ 13-87
Parameter Declaration........................................................................................................................ 13-90
Procedure Declaration and Definition............................................................................................ 13-92
RAISE Statement................................................................................................................................. 13-94
Record Definition................................................................................................................................ 13-95
RESTRICT_REFERENCES Pragma................................................................................................. 13-98
RETURN Statement.......................................................................................................................... 13-100
RETURNING INTO Clause............................................................................................................ 13-102
%ROWTYPE Attribute..................................................................................................................... 13-105
SELECT INTO Statement................................................................................................................ 13-107
SERIALLY_REUSABLE Pragma..................................................................................................... 13-111
SQL (Implicit) Cursor Attribute..................................................................................................... 13-113
SQLCODE Function......................................................................................................................... 13-116
SQLERRM Function......................................................................................................................... 13-117
%TYPE Attribute............................................................................................................................... 13-119
Variable................................................................................................................................................ 13-121
SQL Statements for Stored PL/SQL Units
ALTER FUNCTION Statement .......................................................................................................... 14-3
ALTER PACKAGE Statement ............................................................................................................ 14-6
ALTER PROCEDURE Statement ...................................................................................................... 14-9
ALTER TRIGGER Statement ........................................................................................................... 14-11
ALTER TYPE Statement .................................................................................................................... 14-14
CREATE FUNCTION Statement...................................................................................................... 14-27
CREATE PACKAGE Statement........................................................................................................ 14-36
CREATE PACKAGE BODY Statement .......................................................................................... 14-39
CREATE PROCEDURE Statement................................................................................................... 14-42
CREATE TRIGGER Statement......................................................................................................... 14-47
CREATE TYPE Statement ................................................................................................................. 14-60
CREATE TYPE BODY Statement .................................................................................................... 14-77
DROP FUNCTION Statement.......................................................................................................... 14-82
DROP PACKAGE Statement............................................................................................................ 14-84
xviii
DROP PROCEDURE Statement....................................................................................................... 14-86
DROP TRIGGER Statement............................................................................................................. 14-87
DROP TYPE Statement...................................................................................................................... 14-88
DROP TYPE BODY Statement......................................................................................................... 14-90
A Wrapping PL/SQL Source Code
Overview of Wrapping........................................................................................................................... A-1
Guidelines for Wrapping....................................................................................................................... A-1
Limitations of Wrapping........................................................................................................................ A-2
Wrapping PL/SQL Code with wrap Utility........................................................................................ A-2
Input and Output Files for the PL/SQL wrap Utility.................................................................. A-3
Running the wrap Utility................................................................................................................. A-3
Limitations of the wrap Utility........................................................................................................ A-4
Wrapping PL/QL Code with DBMS_DDL Subprograms................................................................ A-4
Using DBMS_DDL.CREATE_WRAPPED Procedure.................................................................. A-5
Limitation of the DBMS_DDL.WRAP Function ........................................................................... A-6
B How PL/SQL Resolves Identifier Names
What is Name Resolution?.................................................................................................................... B-1
Examples of Qualified Names and Dot Notation............................................................................. B-2
How Name Resolution Differs in PL/SQL and SQL........................................................................ B-4
What is Capture?...................................................................................................................................... B-4
Inner Capture..................................................................................................................................... B-4
Same-Scope Capture......................................................................................................................... B-5
Outer Capture.................................................................................................................................... B-5
Avoiding Inner Capture in DML Statements.................................................................................... B-5
Qualifying References to Attributes and Methods....................................................................... B-6
Qualifying References to Row Expressions................................................................................... B-7
C PL/SQL Program Limits
D PL/SQL Reserved Words and Keywords
Index
xix
xx
List of Examples
1–1 PL/SQL Block Structure ............................................................................................................ 1-4
1–2 PL/SQL Variable Declarations ................................................................................................. 1-7
1–3 Assigning Values to Variables with the Assignment Operator ........................................... 1-7
1–4 Using SELECT INTO to Assign Values to Variables ............................................................. 1-8
1–5 Assigning Values to Variables as Parameters of a Subprogram.......................................... 1-8
1–6 Using %ROWTYPE with an Explicit Cursor........................................................................ 1-10
1–7 Using a PL/SQL Collection Type.......................................................................................... 1-11
1–8 Declaring a Record Type......................................................................................................... 1-12
1–9 Defining an Object Type ......................................................................................................... 1-13
1–10 Using the IF-THEN-ELSE and CASE Statement for Conditional Control ...................... 1-14
1–11 Using the FOR-LOOP.............................................................................................................. 1-15
1–12 Using WHILE-LOOP for Control .......................................................................................... 1-15
1–13 Using the EXIT-WHEN Statement ........................................................................................ 1-16
1–14 Using the GOTO Statement.................................................................................................... 1-17
1–15 PL/SQL Procedure .................................................................................................................. 1-17
1–16 Creating a Standalone PL/SQL Procedure .......................................................................... 1-18
1–17 Invoking a Standalone Procedure from SQL*Plus.............................................................. 1-19
1–18 Creating a Trigger.................................................................................................................... 1-20
1–19 Creating a Package and Package Body................................................................................. 1-20
1–20 Invoking a Procedure in a Package ....................................................................................... 1-22
1–21 Processing Query Results in a LOOP.................................................................................... 1-23
2–1 NUMBER Literals ....................................................................................................................... 2-7
2–2 Using BINARY_FLOAT and BINARY_DOUBLE.................................................................. 2-7
2–3 Using DateTime Literals ............................................................................................................ 2-8
2–4 Single-Line Comments ............................................................................................................... 2-9
2–5 Multiline Comment ................................................................................................................. 2-10
2–6 Declaring Variables.................................................................................................................. 2-11
2–7 Declaring Constants................................................................................................................. 2-11
2–8 Assigning Default Values to Variables with DEFAULT Keyword................................... 2-12
2–9 Declaring Variables with NOT NULL Constraint .............................................................. 2-12
2–10 Using %TYPE to Declare Variables of the Types of Other Variables............................... 2-13
2–11 Using %TYPE Incorrectly with NOT NULL Referenced Type ......................................... 2-13
2–12 Using %TYPE Correctly with NOT NULL Referenced Type............................................ 2-13
2–13 Using %TYPE to Declare Variables of the Types of Table Columns................................ 2-14
2–14 Using %ROWTYPE to Declare a Record that Represents a Table Row........................... 2-15
2–15 Declaring a Record that Represents a Subset of Table Columns ...................................... 2-15
2–16 Declaring a Record that Represents a Row from a Join ..................................................... 2-16
2–17 Assigning One Record to Another, Correctly and Incorrectly.......................................... 2-16
2–18 Using SELECT INTO for Aggregate Assignment ............................................................... 2-17
2–19 Using an Alias for an Expression Associated with %ROWTYPE ..................................... 2-17
2–20 Duplicate Identifiers in Same Scope...................................................................................... 2-19
2–21 Case Insensitivity of Identifiers ............................................................................................. 2-20
2–22 Using a Block Label for Name Resolution............................................................................ 2-20
2–23 Using a Subprogram Name for Name Resolution .............................................................. 2-21
2–24 Scope and Visibility of Identifiers ......................................................................................... 2-23
2–25 Qualifying a Redeclared Global Identifier with a Block Label.......................................... 2-23
2–26 Qualifying an Identifier with a Subprogram Name ........................................................... 2-24
2–27 Label and Subprogram with Same Name in Same Scope.................................................. 2-25
2–28 Block with Multiple and Duplicate Labels........................................................................... 2-25
2–29 Variable Initialized to NULL by Default .............................................................................. 2-26
2–30 Assigning BOOLEAN Values ................................................................................................ 2-27
2–31 Assigning Query Results to Variables .................................................................................. 2-27
2–32 Concatenation Operator.......................................................................................................... 2-28
2–33 Operator Precedence ............................................................................................................... 2-29
xxi
2–34 AND Operator.......................................................................................................................... 2-30
2–35 OR Operator.............................................................................................................................. 2-31
2–36 NOT Operator .......................................................................................................................... 2-32
2–37 Changing Order of Evaluation of Logical Operators ......................................................... 2-33
2–38 Short-Circuit Evaluation ......................................................................................................... 2-34
2–39 Relational Operators................................................................................................................ 2-35
2–40 LIKE Operator .......................................................................................................................... 2-36
2–41 Escape Character in Pattern.................................................................................................... 2-36
2–42 BETWEEN Operator................................................................................................................ 2-37
2–43 IN Operator............................................................................................................................... 2-37
2–44 Using the IN Operator with Sets with NULL Values......................................................... 2-38
2–45 Using BOOLEAN Variables in Conditional Tests............................................................... 2-40
2–46 Using the WHEN Clause with a CASE Statement.............................................................. 2-41
2–47 Using a Search Condition with a CASE Statement ............................................................. 2-41
2–48 NULL Value in Unequal Comparison .................................................................................. 2-43
2–49 NULL Value in Equal Comparison ....................................................................................... 2-43
2–50 NULL Value as Argument to DECODE Function .............................................................. 2-45
2–51 NULL Value as Argument to NVL Function....................................................................... 2-45
2–52 NULL Value as Second Argument to REPLACE Function ............................................... 2-46
2–53 NULL Value as Third Argument to REPLACE Function .................................................. 2-46
2–54 Using Static Constants............................................................................................................. 2-52
2–55 Using DBMS_DB_VERSION Constants ............................................................................... 2-53
2–56 Using Conditional Compilation with Database Versions.................................................. 2-54
2–57 Using PRINT_POST_PROCESSED_SOURCE to Display Source Code .......................... 2-55
3–1 Comparing Two CHAR Values ............................................................................................. 3-10
3–2 Comparing Two VARCHAR2 Values................................................................................... 3-11
3–3 Comparing CHAR Value and VARCHAR2 Value ............................................................. 3-11
3–4 Assigning a Literal Value to a TIMESTAMP Variable ....................................................... 3-17
3–5 Using the SCN_TO_TIMESTAMP and TIMESTAMP_TO_SCN Functions.................... 3-17
3–6 Assigning a Literal to a TIMESTAMP WITH TIME ZONE Variable............................... 3-18
3–7 Correct Assignment to TIMESTAMP WITH LOCAL TIME ZONE................................. 3-19
3–8 Incorrect Assigment to TIMESTAMP WITH LOCAL TIME ZONE................................. 3-20
3–9 Assigning Literals to an INTERVAL YEAR TO MONTH Variable ................................. 3-20
3–10 Assigning Literals to an INTERVAL DAY TO SECOND Variable .................................. 3-21
3–11 Using Ranges with Subtypes.................................................................................................. 3-25
3–12 Type Compatibility with the NUMBER Data Type............................................................ 3-26
3–13 Assigning Default Value to Subtype Variable..................................................................... 3-26
3–14 Subtype Constraints Inherited by Subprograms................................................................. 3-27
3–15 Column Constraints Inherited by Subtypes......................................................................... 3-27
3–16 Implicit Conversion ................................................................................................................. 3-29
4–1 Simple IF-THEN Statement ....................................................................................................... 4-2
4–2 Using a Simple IF-THEN-ELSE Statement.............................................................................. 4-3
4–3 Nested IF-THEN-ELSE Statements .......................................................................................... 4-3
4–4 Using the IF-THEN-ELSIF Statement ...................................................................................... 4-4
4–5 Extended IF-THEN Statement ................................................................................................. 4-4
4–6 Simple CASE Statement ............................................................................................................. 4-5
4–7 Searched CASE Statement ......................................................................................................... 4-6
4–8 Using EXCEPTION Instead of ELSE Clause in CASE Statement ........................................ 4-7
4–9 EXIT Statement............................................................................................................................ 4-9
4–10 Using an EXIT-WHEN Statement.......................................................................................... 4-10
4–11 CONTINUE Statement............................................................................................................ 4-11
4–12 CONTINUE-WHEN Statement ............................................................................................. 4-11
4–13 Labeled Loops .......................................................................................................................... 4-12
4–14 Simple FOR-LOOP Statement................................................................................................ 4-14
4–15 Reverse FOR-LOOP Statement .............................................................................................. 4-14
xxii
4–16 Several Types of FOR-LOOP Bounds ................................................................................... 4-15
4–17 Changing the Increment of the Counter in a FOR-LOOP Statement ............................... 4-16
4–18 Specifying a LOOP Range at Run Time................................................................................ 4-16
4–19 FOR-LOOP with Lower Bound > Upper Bound................................................................. 4-16
4–20 Referencing Counter Variable Outside Loop....................................................................... 4-17
4–21 Using Existing Variable as Loop Variable............................................................................ 4-18
4–22 Referencing Global Variable with Same Name as Loop Counter..................................... 4-18
4–23 Referencing Outer Counter with Same Name as Inner Counter ...................................... 4-18
4–24 EXIT in a FOR LOOP............................................................................................................... 4-19
4–25 EXIT with a Label in a FOR LOOP ........................................................................................ 4-19
4–26 Simple GOTO Statement......................................................................................................... 4-20
4–27 Incorrect Label Placement....................................................................................................... 4-21
4–28 Using a NULL Statement to Allow a GOTO to a Label ..................................................... 4-21
4–29 Using a GOTO Statement to Branch to an Enclosing Block............................................... 4-22
4–30 GOTO Statement Cannot Branch into IF Statement ........................................................... 4-22
4–31 Using the NULL Statement to Show No Action.................................................................. 4-23
4–32 Using NULL as a Placeholder When Creating a Subprogram.......................................... 4-24
4–33 Using the NULL Statement in WHEN OTHER Clause...................................................... 4-24
5–1 Declaring and Using an Associative Array............................................................................. 5-2
5–2 Declaring an Associative Array ................................................................................................ 5-7
5–3 Declaring Nested Tables, Varrays, and Associative Arrays................................................. 5-8
5–4 Declaring Collections with %TYPE .......................................................................................... 5-8
5–5 Declaring a Procedure Parameter as a Nested Table............................................................. 5-9
5–6 Invoking a Procedure with a Nested Table Parameter ......................................................... 5-9
5–7 Specifying Collection Element Types with %TYPE and %ROWTYPE ............................... 5-9
5–8 VARRAY of Records................................................................................................................ 5-10
5–9 NOT NULL Constraint on Collection Elements.................................................................. 5-10
5–10 Constructor for a Nested Table.............................................................................................. 5-10
5–11 Constructor for a Varray......................................................................................................... 5-11
5–12 Collection Constructor Including Null Elements................................................................ 5-11
5–13 Combining Collection Declaration and Constructor .......................................................... 5-11
5–14 Empty Varray Constructor ..................................................................................................... 5-11
5–15 Referencing a Nested Table Element .................................................................................... 5-12
5–16 Referencing an Element of an Associative Array................................................................ 5-13
5–17 Data Type Compatibility for Collection Assignment ......................................................... 5-14
5–18 Assigning a Null Value to a Nested Table ........................................................................... 5-14
5–19 Assigning Nested Tables with Set Operators ...................................................................... 5-15
5–20 Assigning Values to VARRAYs with Complex Data Types.............................................. 5-15
5–21 Assigning Values to Tables with Complex Data Types ..................................................... 5-16
5–22 Checking if a Collection Is Null ............................................................................................. 5-17
5–23 Comparing Two Nested Tables ............................................................................................. 5-18
5–24 Comparing Nested Tables with Set Operators.................................................................... 5-18
5–25 Multilevel VARRAY ................................................................................................................ 5-19
5–26 Multilevel Nested Table.......................................................................................................... 5-19
5–27 Multilevel Associative Array ................................................................................................. 5-20
5–28 Checking Whether a Collection Element EXISTS................................................................ 5-21
5–29 Counting Collection Elements with COUNT ...................................................................... 5-22
5–30 Checking the Maximum Size of a Collection with LIMIT ................................................. 5-22
5–31 Using FIRST and LAST with a Collection ............................................................................ 5-23
5–32 Using PRIOR and NEXT to Access Collection Elements ................................................... 5-24
5–33 Using NEXT to Access Elements of a Nested Table ........................................................... 5-24
5–34 Using EXTEND to Increase the Size of a Collection ........................................................... 5-25
5–35 Using TRIM to Decrease the Size of a Collection ................................................................ 5-26
5–36 Using TRIM on Deleted Elements ......................................................................................... 5-27
5–37 Using the DELETE Method on a Collection......................................................................... 5-27
xxiii
5–38 Collection Exceptions .............................................................................................................. 5-28
5–39 How Invalid Subscripts are Handled with DELETE(n) ..................................................... 5-30
5–40 Incompatibility Between Package and Local Collection Types ........................................ 5-30
5–41 Declaring and Initializing a Simple Record Type ............................................................... 5-31
5–42 Declaring and Initializing Record Types.............................................................................. 5-31
5–43 Using %ROWTYPE to Declare a Record .............................................................................. 5-32
5–44 Returning a Record from a Function..................................................................................... 5-33
5–45 Using a Record as Parameter to a Procedure....................................................................... 5-33
5–46 Declaring a Nested Record ..................................................................................................... 5-34
5–47 Assigning Default Values to a Record .................................................................................. 5-34
5–48 Assigning All the Fields of a Record in One Statement ..................................................... 5-35
5–49 Using SELECT INTO to Assign Values in a Record ........................................................... 5-35
5–50 Inserting a PL/SQL Record Using %ROWTYPE ................................................................ 5-36
5–51 Updating a Row Using a Record ........................................................................................... 5-37
5–52 Using the RETURNING INTO Clause with a Record ........................................................ 5-37
5–53 Using BULK COLLECT with a SELECT INTO Statement................................................. 5-38
6–1 Data Manipulation with PL/SQL............................................................................................. 6-1
6–2 Checking SQL%ROWCOUNT After an UPDATE................................................................. 6-2
6–3 Substituting PL/SQL Variables ................................................................................................ 6-2
6–4 Invoking the SQL COUNT Function in PL/SQL ................................................................... 6-3
6–5 Using CURRVAL and NEXTVAL ............................................................................................ 6-4
6–6 Using ROWNUM........................................................................................................................ 6-6
6–7 Using SQL%FOUND .................................................................................................................. 6-8
6–8 Using SQL%ROWCOUNT ........................................................................................................ 6-8
6–9 Declaring a Cursor................................................................................................................... 6-10
6–10 Fetching with a Cursor............................................................................................................ 6-11
6–11 Referencing PL/SQL Variables Within Its Scope................................................................ 6-12
6–12 Fetching the Same Cursor Into Different Variables ............................................................ 6-12
6–13 Fetching Bulk Data with a Cursor ......................................................................................... 6-12
6–14 Using %FOUND....................................................................................................................... 6-14
6–15 Using %ISOPEN....................................................................................................................... 6-14
6–16 Using %NOTFOUND.............................................................................................................. 6-14
6–17 Using %ROWCOUNT............................................................................................................. 6-15
6–18 Using an Alias For Expressions in a Query.......................................................................... 6-19
6–19 Using a Subquery in a Cursor ................................................................................................ 6-19
6–20 Using a Subquery in a FROM Clause.................................................................................... 6-20
6–21 Using a Correlated Subquery................................................................................................. 6-21
6–22 Passing Parameters to a Cursor FOR Loop.......................................................................... 6-21
6–23 Passing Parameters to Explicit Cursors ................................................................................ 6-21
6–24 Cursor Variable Returning a %ROWTYPE Variable .......................................................... 6-24
6–25 Using the %ROWTYPE Attribute to Provide the Data Type............................................. 6-24
6–26 Cursor Variable Returning a Record Type........................................................................... 6-24
6–27 Passing a REF CURSOR as a Parameter ............................................................................... 6-24
6–28 Checking If a Cursor Variable is Open ................................................................................. 6-26
6–29 Stored Procedure to Open a Ref Cursor ............................................................................... 6-26
6–30 Stored Procedure to Open Ref Cursors with Different Queries........................................ 6-26
6–31 Cursor Variable with Different Return Types ..................................................................... 6-27
6–32 Fetching from a Cursor Variable into a Record................................................................... 6-28
6–33 Fetching from a Cursor Variable into Collections............................................................... 6-28
6–34 Declaration of Cursor Variables in a Package ..................................................................... 6-30
6–35 Using a Cursor Expression ..................................................................................................... 6-31
6–36 Using COMMIT with the WRITE Clause............................................................................. 6-33
6–37 Using ROLLBACK................................................................................................................... 6-34
6–38 Using SAVEPOINT with ROLLBACK.................................................................................. 6-35
6–39 reusing a SAVEPOINT with ROLLBACK............................................................................ 6-36
xxiv
6–40 Using SET TRANSACTION to Begin a Read-only Transaction ....................................... 6-37
6–41 Using CURRENT OF to Update the Latest Row Fetched from a Cursor ........................ 6-38
6–42 Fetching Across COMMITs Using ROWID ......................................................................... 6-40
6–43 Declaring an Autonomous Function in a Package.............................................................. 6-42
6–44 Declaring an Autonomous Standalone Procedure.............................................................. 6-42
6–45 Declaring an Autonomous PL/SQL Block........................................................................... 6-42
6–46 Declaring an Autonomous Trigger ....................................................................................... 6-43
6–47 Using Autonomous Triggers.................................................................................................. 6-45
6–48 Invoking an Autonomous Function ...................................................................................... 6-46
7–1 Invoking a Subprogram from a Dynamic PL/SQL Block..................................................... 7-3
7–2 Unsupported Data Type in Native Dynamic SQL ................................................................. 7-3
7–3 Uninitialized Variable for NULL in USING Clause .............................................................. 7-4
7–4 Native Dynamic SQL with OPEN-FOR, FETCH, and CLOSE Statements ........................ 7-4
7–5 Repeated Placeholder Names in Dynamic PL/SQL Block ................................................... 7-6
7–6 Switching from DBMS_SQL Package to Native Dynamic SQL ........................................... 7-7
7–7 Switching from Native Dynamic SQL to DBMS_SQL Package ........................................... 7-8
7–8 Setup for SQL Injection Examples ............................................................................................ 7-9
7–9 Procedure Vulnerable to Statement Modification............................................................... 7-10
7–10 Procedure Vulnerable to Statement Injection ...................................................................... 7-11
7–11 Procedure Vulnerable to SQL Injection Through Data Type Conversion....................... 7-13
7–12 Using Bind Arguments to Guard Against SQL Injection................................................... 7-14
7–13 Using Validation Checks to Guard Against SQL Injection................................................ 7-16
7–14 Using Explicit Format Models to Guard Against SQL Injection....................................... 7-17
8–1 Declaring, Defining, and Invoking a Simple PL/SQL Procedure ....................................... 8-3
8–2 Declaring, Defining, and Invoking a Simple PL/SQL Function.......................................... 8-5
8–3 Creating Nested Subprograms that Invoke Each Other........................................................ 8-6
8–4 Formal Parameters and Actual Parameters ............................................................................ 8-6
8–5 Using OUT Mode........................................................................................................................ 8-8
8–6 Procedure with Default Parameter Values........................................................................... 8-10
8–7 Formal Parameter with Expression as Default Value......................................................... 8-10
8–8 Subprogram Calls Using Positional, Named, and Mixed Notation ................................. 8-11
8–9 Overloading a Subprogram Name ........................................................................................ 8-12
8–10 Package Specification with Overloading Violation that Causes Compile-Time Error.. 8-15
8–11 Package Specification with Overloading Violation that Compiles Without Error ........ 8-15
8–12 Invocation of Improperly Overloaded Subprogram .......................................................... 8-15
8–13 Package Specification Without Overloading Violations .................................................... 8-16
8–14 Improper Invocation of Properly Overloaded Subprogram ............................................. 8-16
8–15 Resolving PL/SQL Procedure Names .................................................................................. 8-17
8–16 Creating an Object Type with AUTHID CURRENT USER ............................................... 8-21
8–17 Invoking an IR Instance Methods.......................................................................................... 8-22
8–18 Invoking an External Procedure from PL/SQL .................................................................. 8-24
8–19 Invoking a Java Function from PL/SQL .............................................................................. 8-24
8–20 RESTRICT_REFERENCES Pragma ....................................................................................... 8-25
8–21 Aliasing from Passing Global Variable with NOCOPY Hint............................................ 8-25
8–22 Aliasing Passing Same Parameter Multiple Times ............................................................. 8-26
8–23 Aliasing from Assigning Cursor Variables to Same Work Area....................................... 8-26
8–24 Declaration and Definition of Result-Cached Function ..................................................... 8-28
8–25 Result-Cached Function that Returns Configuration Parameter Setting ........................ 8-31
8–26.................................................................................................................................................... 8-33
8–27 Result-Cached Function that Depends on Session-Specific Application Context.......... 8-35
8–28 Caching One Name at a Time (Finer Granularity).............................................................. 8-36
8–29 Caching Translated Names One Language at a Time (Coarser Granularity)................. 8-36
9–1 CREATE TRIGGER Statement .................................................................................................. 9-5
9–2 Compound Trigger .................................................................................................................. 9-14
9–3 Compound Trigger Records Changes to One Table in Another Table............................ 9-16
xxv
9–4 Compound Trigger that Avoids Mutating-Table Error ..................................................... 9-18
9–5 Monitoring Logons with a Trigger........................................................................................ 9-19
9–6 Invoking a Java Subprogram from a Trigger....................................................................... 9-19
10–1 A Simple Package Specification Without a Body................................................................ 10-4
10–2 Matching Package Specifications and Bodies ...................................................................... 10-5
10–3 Creating the emp_admin Package......................................................................................... 10-6
10–4 Using PUT_LINE in the DBMS_OUTPUT Package.......................................................... 10-10
10–5 Separating Cursor Specifications with Packages .............................................................. 10-12
11–1 Run-Time Error Handling ...................................................................................................... 11-2
11–2 Managing Multiple Errors with a Single Exception Handler............................................ 11-3
11–3 Scope of PL/SQL Exceptions ................................................................................................. 11-7
11–4 Using PRAGMA EXCEPTION_INIT .................................................................................... 11-8
11–5 Raising an Application Error with RAISE_APPLICATION_ERROR .............................. 11-8
11–6 Using RAISE to Raise a User-Defined Exception................................................................ 11-9
11–7 Using RAISE to Raise a Predefined Exception .................................................................. 11-10
11–8 Scope of an Exception............................................................................................................ 11-12
11–9 Reraising a PL/SQL Exception ............................................................................................ 11-13
11–10 Raising an Exception in a Declaration ................................................................................ 11-14
11–11 Displaying SQLCODE and SQLERRM............................................................................... 11-15
11–12 Continuing After an Exception ............................................................................................ 11-17
11–13 Retrying a Transaction After an Exception ........................................................................ 11-18
11–14 Using a Locator Variable to Identify the Location of an Exception................................ 11-18
11–15 Controlling the Display of PL/SQL Warnings.................................................................. 11-20
11–16 Using the DBMS_WARNING Package to Display Warnings ......................................... 11-20
12–1 Nesting a Query to Improve Performance........................................................................... 12-4
12–2 Issuing DELETE Statements in a Loop ............................................................................... 12-10
12–3 Issuing INSERT Statements in a Loop ................................................................................ 12-11
12–4 Using FORALL with Part of a Collection........................................................................... 12-11
12–5 Using FORALL with Nonconsecutive Index Values ........................................................ 12-12
12–6 Using Rollbacks with FORALL............................................................................................ 12-14
12–7 Using %BULK_ROWCOUNT with the FORALL Statement........................................... 12-14
12–8 Counting Rows Affected by FORALL with %BULK_ROWCOUNT ............................. 12-15
12–9 Bulk Operation that Continues Despite Exceptions ......................................................... 12-16
12–10 Retrieving Query Results with BULK COLLECT ............................................................. 12-17
12–11 Using the Pseudocolumn ROWNUM to Limit Query Results........................................ 12-18
12–12 Bulk-Fetching from a Cursor Into One or More Collections ........................................... 12-19
12–13 Bulk-Fetching from a Cursor Into a Collection of Records.............................................. 12-20
12–14 Using LIMIT to Control the Number of Rows In a BULK COLLECT ........................... 12-20
12–15 Using BULK COLLECT with the RETURNING INTO Clause ....................................... 12-21
12–16 Using FORALL with BULK COLLECT .............................................................................. 12-21
12–17 SELECT BULK COLLECT INTO Statement with Unexpected Results ......................... 12-22
12–18 Workaround for Example 12–17 Using a Cursor .............................................................. 12-23
12–19 Workaround for Example 12–17 Using a Second Collection........................................... 12-25
12–20 Using NOCOPY with Parameters ....................................................................................... 12-28
12–21 Assigning the Result of a Table Function........................................................................... 12-35
12–22 Using a Pipelined Table Function For a Transformation................................................. 12-36
12–23 Using Multiple REF CURSOR Input Variables ................................................................. 12-39
12–24 Using a Pipelined Table Function as an Aggregate Function ......................................... 12-40
13–1 Specifying that a Subprogram Is To Be Inlined................................................................. 13-74
13–2 Specifying that an Overloaded Subprogram Is To Be Inlined......................................... 13-74
13–3 Specifying that a Subprogram Is Not To Be Inlined ......................................................... 13-75
13–4 Applying Two INLINE Pragmas to the Same Subprogram............................................ 13-75
13–5 Creating a Serially Reusable Package ............................................................................... 13-111
A–1 Using DBMS_DDL.CREATE_WRAPPED Procedure to Wrap a Package......................... A-5
B–1 Resolving Global and Local Variable Names ........................................................................ B-1
xxvi
B–2 Using the Dot Notation to Qualify Names............................................................................. B-2
xxvii
List of Figures
1–1 PL/SQL Boosts Performance .................................................................................................... 1-2
1–2 PL/SQL Engine ........................................................................................................................ 1-24
4–1 Control Structures....................................................................................................................... 4-1
5–1 Array and Nested Table............................................................................................................. 5-5
5–2 Varray of Size 10.......................................................................................................................... 5-5
6–1 Transaction Control Flow ....................................................................................................... 6-41
8–1 How the PL/SQL Compiler Resolves Calls......................................................................... 8-17
10–1 Package Scope........................................................................................................................... 10-4
11–1 Propagation Rules: Example 1 ............................................................................................. 11-11
11–2 Propagation Rules: Example 2 ............................................................................................. 11-11
11–3 Propagation Rules: Example 3 ............................................................................................. 11-12
xxviii
List of Tables
1–1 PL/SQL Compilation Parameters ........................................................................................ 1-25
2–1 PL/SQL Delimiters.................................................................................................................... 2-3
2–2 Operator Precedence .............................................................................................................. 2-29
2–3 Logical Truth Table................................................................................................................. 2-30
2–4 Relational Operators............................................................................................................... 2-35
3–1 Categories of Predefined PL/SQL Data Types...................................................................... 3-1
3–2 Categories of Predefined PL/SQL Scalar Data Types.......................................................... 3-2
3–3 Predefined PL/SQL Numeric Data Types ............................................................................. 3-2
3–4 Predefined Subtypes of PLS_INTEGER Data Type .............................................................. 3-3
3–5 Predefined PL/SQL BINARY_FLOAT and BINARY_DOUBLE Constants ..................... 3-5
3–6 Predefined Subtypes of NUMBER Data Type ....................................................................... 3-7
3–7 Predefined PL/SQL Character Data Types............................................................................ 3-7
3–8 Comparison of AL16UTF16 and UTF8 Encodings............................................................. 3-13
3–9 Predefined PL/SQL Large Object (LOB) Data Types........................................................ 3-22
3–10 Possible Implicit PL/SQL Data Type Conversions............................................................ 3-31
5–1 Characteristics of PL/SQL Collection Types ......................................................................... 5-2
6–1 Cursor Attribute Values......................................................................................................... 6-15
8–1 Parameter Modes ....................................................................................................................... 8-9
8–2 PL/SQL Subprogram Parameter Notations........................................................................ 8-11
8–3 Comparison of Finer and Coarser Caching Granularity................................................... 8-35
9–1 Timing-Point Sections of a Compound Trigger Defined .................................................. 9-15
9–2 Comparison of Built-in Auditing and Trigger-Based Auditing...................................... 9-31
9–3 System-Defined Event Attributes........................................................................................ 9-47
9–4 Database Events ..................................................................................................................... 9-50
9–5 Client Events........................................................................................................................... 9-51
11–1 Predefined PL/SQL Exceptions............................................................................................ 11-4
11–2 PL/SQL Warning Categories .............................................................................................. 11-19
C–1 PL/SQL Compiler Limits ........................................................................................................ C-1
D–1 PL/SQL Reserved Words ........................................................................................................ D-1
D–2 PL/SQL Keywords ................................................................................................................... D-2