Here is the detailed content for **Part VII, Section B: Go**, structured as a study guide file.

***

# 007-Language-Deep-Dives / 002-Go.md

## OpenTelemetry in Go: Context, Concurrency, and Manual Wiring

Go (Golang) is unique in the observability landscape. Unlike Java (which uses bytecode manipulation for "magic" agents) or Python/Node.js (which can monkey-patch runtime classes), **Go relies on explicit compilation and strong typing**.

While eBPF-based solutions exist for zero-code instrumentation in Go, the industry standard is **library-based instrumentation**. This requires a deep understanding of `context.Context`, how to wire the SDK manually, and how to handle concurrency via Goroutines.

---

### 1. The Philosophy: Explicit Context Passing
In Go, OpenTelemetry relies entirely on the standard library `context` package.
*   **Storage:** The current active Span is stored *inside* the `context.Context` struct.
*   **Propagation:** To create a child span, you must pass the context containing the parent span to the `Tracer`.
*   **Mutability:** Contexts are immutable. When you start a span, you get back a **new** context object containing that new span. You must pass this *new* context downstream.

---

### 2. Manual Wiring of SDK Components

In Go, there is no "auto-attach" agent. You must write a bootstrap function (usually in your `main.go`) to initialize the `TracerProvider`.

#### The Initialization Boilerplate
A robust production setup requires wiring up five distinct components:
1.  **Context**: The background context.
2.  **Exporter**: Where data goes (OTLP, Stdout, Jaeger).
3.  **Resource**: Metadata describing "Who am I?" (Service Name, Version).
4.  **Processor**: How to handle data (Batch vs. Simple).
5.  **Propagator**: How to parse/inject HTTP headers (W3C TraceContext).

**Code Example: `main.go` initialization**

```go
package main

import (
	"context"
	"log"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
)

func initTracer() (func(context.Context) error, error) {
	ctx := context.Background()

	// 1. Create the Exporter (sending to a Collector via gRPC)
	exporter, err := otlptracegrpc.New(ctx, 
        otlptracegrpc.WithInsecure(), 
        otlptracegrpc.WithEndpoint("localhost:4317"),
    )
	if err != nil {
		return nil, err
	}

	// 2. Define the Resource (Service Name is critical)
	res, err := resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName("my-go-service"),
			semconv.ServiceVersion("1.0.0"),
		),
	)
	if err != nil {
		return nil, err
	}

	// 3. Create the TracerProvider with a BatchSpanProcessor
	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exporter),
		sdktrace.WithResource(res),
	)

	// 4. Set the Global TracerProvider
    // This allows libraries (like fiber, gin, gorm) to find the tracer 
    // without you passing it explicitly.
	otel.SetTracerProvider(tp)

	// 5. Set the Global Propagator
    // This ensures W3C TraceContext headers are read/written automatically.
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{}, 
        propagation.Baggage{},
    ))

	// Return a shutdown function to flush data on app exit
	return tp.Shutdown, nil
}

func main() {
    // Initialize
	shutdown, err := initTracer()
	if err != nil {
		log.Fatal(err)
	}
    // Ensure we flush buffered spans before the app exits
	defer func() {
		if err := shutdown(context.Background()); err != nil {
			log.Fatal(err)
		}
	}()

	// ... Your application logic here ...
}
```

---

### 3. Context Handling and Spans

Once the globals are set, you use the `otel` package to get a tracer.

#### Creating Spans
The pattern involves `Start` and `End`. The `defer` keyword is idiomatic in Go to ensure spans close even if the function panics or returns early.

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
)

var tracer = otel.Tracer("my-package-name")

func doWork(ctx context.Context) {
    // Start returns a NEW context (ctx) and the Span
    ctx, span := tracer.Start(ctx, "doWork")
    defer span.End()

    // Add attributes
    span.SetAttributes(attribute.String("work.type", "calculation"))

    // Pass the NEW ctx to child functions so they become child spans
    stepTwo(ctx)
}

func stepTwo(ctx context.Context) {
    ctx, span := tracer.Start(ctx, "stepTwo")
    defer span.End()
    
    // logic...
}
```

#### Crucial Gotcha: The Shadowed Context
A common mistake in Go is ignoring the returned context:

```go
// BAD
_, span := tracer.Start(ctx, "operation")
childFunction(ctx) // This child will NOT be linked to "operation"!

// GOOD
ctx, span := tracer.Start(ctx, "operation")
childFunction(ctx) // This child IS linked properly.
```

---

### 4. Goroutines and Context Propagation

Go makes concurrency easy, but "fire and forget" Goroutines can break trace continuity if not handled correctly.

#### The Race Condition
If you launch a Goroutine and use the *same* context, the parent function might return (ending the parent span) while the Goroutine is still running.

#### Pattern 1: Synchronous Goroutines (WaitGroups)
If you wait for the Goroutine, standard context propagation works fine.

```go
func processItems(ctx context.Context) {
    ctx, span := tracer.Start(ctx, "processItems")
    defer span.End()

    var wg sync.WaitGroup
    wg.Add(1)
    
    go func(c context.Context) {
        defer wg.Done()
        // Create a child span inside the goroutine
        // It properly links to "processItems"
        _, subSpan := tracer.Start(c, "async-job") 
        defer subSpan.End()
        time.Sleep(1 * time.Second)
    }(ctx) // Pass the ctx explicitly

    wg.Wait()
}
```

#### Pattern 2: Fire-and-Forget (Background Tasks)
If the Goroutine outlives the parent request (e.g., sending an email after an HTTP response), the parent context might be cancelled (causing the child span to error or be cancelled).

You need to create a **Link** instead of a direct Child, or create a new Root span that references the old one.

```go
func fireAndForget(ctx context.Context) {
    // 1. Extract TraceID/SpanID from the current context to use as a link
    link := trace.LinkFromContext(ctx)

    go func() {
        // 2. Start a NEW background context
        bgCtx := context.Background()
        
        // 3. Start a new root span, but link it to the original request
        _, span := tracer.Start(bgCtx, "email-sender", trace.WithLinks(link))
        defer span.End()

        // Send email logic...
    }()
}
```

---

### 5. Integration: HTTP and SQL

You rarely manually instrument every single function. You rely on standard middleware.

#### HTTP Middleware (`otelhttp`)
This wrapper automatically extracts the `traceparent` header from incoming requests, starts a span, puts it in the `r.Context()`, and calls the next handler.

```go
import "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"

func main() {
    handler := http.HandlerFunc(myHandler)
    
    // Wrap the handler
    wrappedHandler := otelhttp.NewHandler(handler, "my-http-server")
    
    http.ListenAndServe(":8080", wrappedHandler)
}

func myHandler(w http.ResponseWriter, r *http.Request) {
    // OTel has already injected the span into r.Context()
    ctx := r.Context()
    
    // We can continue tracing immediately
    ctx, span := tracer.Start(ctx, "database-query")
    defer span.End()
}
```

#### SQL Instrumentation (`otelsql`)
Instead of using `database/sql` directly, you register an OTel wrapper.

```go
import "github.com/XSAM/otelsql"

// Register the driver
driverName, err := otelsql.Register("postgres", 
    otelsql.WithAttributes(semconv.DBSystemPostgreSQL),
)

// Open database
db, _ := sql.Open(driverName, connStr)

// IMPORTANT: Use Context-aware methods
// db.Query -> BAD (no trace propagation)
// db.QueryContext -> GOOD (propagates trace)
rows, err := db.QueryContext(ctx, "SELECT * FROM users")
```

---

### Summary of Go Deep Dive
1.  **Manual Wiring**: You must initialize `TracerProvider` and `Propagator` explicitly in `main()`.
2.  **Context is King**: `ctx` carries the trace. Always grab the modified `ctx` returned by `Start()` and pass it down.
3.  **Defer End**: Always `defer span.End()` immediately after starting a span.
4.  **Libraries**: Use `contrib` libraries for HTTP, gRPC, and SQL to avoid writing boilerplate, but ensure you call the `Context` versions of their methods (e.g., `QueryContext` vs `Query`).